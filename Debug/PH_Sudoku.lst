
PH_Sudoku.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a14  0c000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000120  0c000a20  0c000a20  00008a20  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  2 .ARM.attributes 0000002e  00000000  00000000  00008b40  2**0
                  CONTENTS, READONLY
  3 .comment      0000002a  00000000  00000000  00008b6e  2**0
                  CONTENTS, READONLY
  4 .debug_line   000004f0  00000000  00000000  00008b98  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000004dc  00000000  00000000  00009088  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000126  00000000  00000000  00009564  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000040  00000000  00000000  00009690  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_macinfo 00006574  00000000  00000000  000096d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000160  00000000  00000000  0000fc44  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 0000006b  00000000  00000000  0000fda4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubtypes 00000035  00000000  00000000  0000fe0f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000001e3  00000000  00000000  0000fe44  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000110  00000000  00000000  00010028  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c000000 <sudoku_candidatos_propagar_arm>:
sudoku_candidatos_propagar_arm:
	@ r0 = cuadricula
	@ r1 = fila
	@ r2 = columna
	@ r3 = valor celda
	push {r0, lr}
 c000000:	e92d4001 	push	{r0, lr}

	mov r4, #0
 c000004:	e3a04000 	mov	r4, #0
    add r4, r3, #3				@ r4 = displace = (3 + valor)
 c000008:	e2834003 	add	r4, r3, #3

	mov r6, #1					@ r6 bit de desactivacion
 c00000c:	e3a06001 	mov	r6, #1
    lsl r6, r6, r4				@ desplazar bit a la izquierda r4 posiciones
 c000010:	e1a06416 	lsl	r6, r6, r4

@ ---------------------------- Actualizar candidatos de las columnas (horizontalmente) ----------------------------
	bl update_column_candidates
 c000014:	eb000003 	bl	c000028 <update_column_candidates>
@ ---------------------------- Actualizar candidatos de las filas (verticalmente) ----------------------------
	bl update_row_candidates
 c000018:	eb00000c 	bl	c000050 <update_row_candidates>
@ ---------------------------- Calculo de los indices para la seccion correspondiente ----------------------------
	bl update_region_candidates
 c00001c:	eb000015 	bl	c000078 <update_region_candidates>

	pop {r0, lr}
 c000020:	e8bd4001 	pop	{r0, lr}
	bx lr
 c000024:	e12fff1e 	bx	lr

0c000028 <update_column_candidates>:


update_column_candidates:
	mov r7, #0
 c000028:	e3a07000 	mov	r7, #0

0c00002c <col_loop>:
col_loop:
    cmp r7, #9					@ Comparar si se ha llegado a la ultima columna (9)
 c00002c:	e3570009 	cmp	r7, #9
    bge fin_col
 c000030:	aa000005 	bge	c00004c <fin_col>

	lsl r8, r7, #1				@ r8 = desplazamiento a siguiente celda
 c000034:	e1a08087 	lsl	r8, r7, #1

	ldrh r9, [r0, r8]
 c000038:	e19090b8 	ldrh	r9, [r0, r8]

    bic r9, r9, r6           	@ celda &= ~(1 << displace)
 c00003c:	e1c99006 	bic	r9, r9, r6
    strh r9, [r0, r8]
 c000040:	e18090b8 	strh	r9, [r0, r8]

    add r7, r7, #1
 c000044:	e2877001 	add	r7, r7, #1
    b col_loop
 c000048:	eafffff7 	b	c00002c <col_loop>

0c00004c <fin_col>:

fin_col:
	bx lr
 c00004c:	e12fff1e 	bx	lr

0c000050 <update_row_candidates>:


update_row_candidates:
	mov r7, #0					@ reinicar contador
 c000050:	e3a07000 	mov	r7, #0

0c000054 <fila_loop>:
fila_loop:
    cmp r7, #9                 @ Comparar si se ha llegado a la ultima fila (9)
 c000054:	e3570009 	cmp	r7, #9
    bge fin_fila
 c000058:	aa000005 	bge	c000074 <fin_fila>

	lsl r8, r7, #5				@ r8 = desplazamiento a siguiente celda
 c00005c:	e1a08287 	lsl	r8, r7, #5

	ldrh r9, [r0, r8]
 c000060:	e19090b8 	ldrh	r9, [r0, r8]

    bic r9, r9, r6           	@ celda &= ~(1 << displace)
 c000064:	e1c99006 	bic	r9, r9, r6
    strh r9, [r0, r8]
 c000068:	e18090b8 	strh	r9, [r0, r8]

    add r7, r7, #1
 c00006c:	e2877001 	add	r7, r7, #1
    b fila_loop
 c000070:	eafffff7 	b	c000054 <fila_loop>

0c000074 <fin_fila>:

fin_fila:
	bx lr
 c000074:	e12fff1e 	bx	lr

0c000078 <update_region_candidates>:


update_region_candidates:
	mov r7, #0
 c000078:	e3a07000 	mov	r7, #0

0c00007c <col_index>:
col_index:
	cmp r2, #3					@ Compara que el dividendo sea mayor que el divisor
 c00007c:	e3520003 	cmp	r2, #3
	blt col_index_end
 c000080:	ba000002 	blt	c000090 <col_index_end>

	sub r2, r2, #3
 c000084:	e2422003 	sub	r2, r2, #3
	add r7, r7, #1
 c000088:	e2877001 	add	r7, r7, #1
	b col_index
 c00008c:	eafffffa 	b	c00007c <col_index>

0c000090 <col_index_end>:

col_index_end:					@ El indice de la seccion por columna queda guardado en r7

	mov r8, #0
 c000090:	e3a08000 	mov	r8, #0

0c000094 <row_index>:
row_index:
	cmp r1, #3					@ Compara que el dividendo sea mayor que el divisor
 c000094:	e3510003 	cmp	r1, #3
	blt row_index_end
 c000098:	ba000002 	blt	c0000a8 <row_index_end>

	sub r1, r1, #3
 c00009c:	e2411003 	sub	r1, r1, #3
	add r8, r8, #1
 c0000a0:	e2888001 	add	r8, r8, #1
	b row_index
 c0000a4:	eafffffa 	b	c000094 <row_index>

0c0000a8 <row_index_end>:

row_index_end:					@ El indice de la seccion por fila queda guardado en r8

@ ---------------------------- Recorrer cada fila y actualizar candidatos de la seccion ----------------------------
	mov r1, r8					@ Mover el indice r8 a r1 (fila)
 c0000a8:	e1a01008 	mov	r1, r8
	mov r2, r7					@ Mover el indice r7 a r2 (columna)
 c0000ac:	e1a02007 	mov	r2, r7

	mov r7, #0					@ Contador de la fila (Verticalmente)
 c0000b0:	e3a07000 	mov	r7, #0

0c0000b4 <row_loop>:
row_loop:
	cmp r7, #3
 c0000b4:	e3570003 	cmp	r7, #3
	bge row_end
 c0000b8:	aa00000e 	bge	c0000f8 <row_end>

	add r8, r1, r7
 c0000bc:	e0818007 	add	r8, r1, r7
	lsl r8, r8, #5				@ Desplazamiento hacia la siguiente fila r8
 c0000c0:	e1a08288 	lsl	r8, r8, #5

	mov r9, #0					@ Contador de la columna (horizontalmente)
 c0000c4:	e3a09000 	mov	r9, #0

0c0000c8 <column_loop>:
	column_loop:
		cmp r9, #3
 c0000c8:	e3590003 	cmp	r9, #3
		bge column_end
 c0000cc:	aa000007 	bge	c0000f0 <column_end>

		add r10, r2, r9
 c0000d0:	e082a009 	add	sl, r2, r9
		lsl r10, r10, #1		@ Desplazamiento a la siguiente columna r10
 c0000d4:	e1a0a08a 	lsl	sl, sl, #1

		add r11, r8, r10
 c0000d8:	e088b00a 	add	fp, r8, sl
		ldrh r12, [r0, r11]		@ Cargar la celda en el registro 12
 c0000dc:	e190c0bb 	ldrh	ip, [r0, fp]

		bic r12, r12, r6		@ celda &= ~(1 << displace)
 c0000e0:	e1ccc006 	bic	ip, ip, r6
		strh r12, [r0, r11]		@ Guardar el nuevo valor en la celda
 c0000e4:	e180c0bb 	strh	ip, [r0, fp]

		add r9, r9, #1
 c0000e8:	e2899001 	add	r9, r9, #1
		b column_loop
 c0000ec:	eafffff5 	b	c0000c8 <column_loop>

0c0000f0 <column_end>:

	column_end:
		add r7, r7, #1
 c0000f0:	e2877001 	add	r7, r7, #1
		b row_loop
 c0000f4:	eaffffee 	b	c0000b4 <row_loop>

0c0000f8 <row_end>:
row_end:
	bx lr
 c0000f8:	e12fff1e 	bx	lr

0c0000fc <start>:
start:
.arm    /* indicates that we are using the ARM instruction set */

#------standard initial code
# --- Setup interrupt / exception vectors
      B       Reset_Handler
 c0000fc:	eaffffff 	b	c000100 <Reset_Handler>

0c000100 <Reset_Handler>:
# Reset Handler:
# the processor starts executing this code after system reset
################################################################################
Reset_Handler:
#
        MOV     sp, #0x4000      /*  set up stack pointer (r13) */
 c000100:	e3a0d901 	mov	sp, #16384	; 0x4000
# If there are 4 or less parameters when calling a C function the compiler
# assumes that they have been stored in r0-r3.
# If there are more parameters you have to store them in the data stack
# using the stack pointer
# function __c_copy is in copy.c
        LDR     r0, =cuadricula  /*  puntero a la @ inicial de la cuadricula */
 c000104:	e59f000c 	ldr	r0, [pc, #12]	; c000118 <stop+0x4>

.extern     sudoku9x9
        ldr         r5, = sudoku9x9
 c000108:	e59f500c 	ldr	r5, [pc, #12]	; c00011c <stop+0x8>
        mov         lr, pc
 c00010c:	e1a0e00f 	mov	lr, pc
        bx          r5
 c000110:	e12fff15 	bx	r5

0c000114 <stop>:

stop:
        B       stop        /*  end of program */
 c000114:	eafffffe 	b	c000114 <stop>
 c000118:	0c000a20 	.word	0x0c000a20
 c00011c:	0c000980 	.word	0x0c000980

0c000120 <celda_leer_valor>:

/* *****************************************************************************
 * extrae el valor almacenado en los 16 bits de una celda */
static inline uint8_t
celda_leer_valor(CELDA celda)
{
 c000120:	e1a0c00d 	mov	ip, sp
 c000124:	e92dd800 	push	{fp, ip, lr, pc}
 c000128:	e24cb004 	sub	fp, ip, #4
 c00012c:	e24dd008 	sub	sp, sp, #8
 c000130:	e1a03000 	mov	r3, r0
 c000134:	e14b30be 	strh	r3, [fp, #-14]
    return (celda & 0x000F);
 c000138:	e15b30be 	ldrh	r3, [fp, #-14]
 c00013c:	e20330ff 	and	r3, r3, #255	; 0xff
 c000140:	e203300f 	and	r3, r3, #15
 c000144:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c000148:	e1a00003 	mov	r0, r3
 c00014c:	e24bd00c 	sub	sp, fp, #12
 c000150:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000154:	e12fff1e 	bx	lr

0c000158 <activar_error>:

static inline void
activar_error(CELDA celda)
{
 c000158:	e1a0c00d 	mov	ip, sp
 c00015c:	e92dd800 	push	{fp, ip, lr, pc}
 c000160:	e24cb004 	sub	fp, ip, #4
 c000164:	e24dd008 	sub	sp, sp, #8
 c000168:	e1a03000 	mov	r3, r0
 c00016c:	e14b30be 	strh	r3, [fp, #-14]
	celda = celda |= 0x4000;
 c000170:	e15b30be 	ldrh	r3, [fp, #-14]
 c000174:	e3833901 	orr	r3, r3, #16384	; 0x4000
 c000178:	e14b30be 	strh	r3, [fp, #-14]
}
 c00017c:	e24bd00c 	sub	sp, fp, #12
 c000180:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000184:	e12fff1e 	bx	lr

0c000188 <sudoku_candidatos_propagar_c>:
 * propaga el valor de una determinada celda
 * para actualizar las listas de candidatos
 * de las celdas en su su fila, columna y region */
void
sudoku_candidatos_propagar_c(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int fila, int columna, uint8_t valor)
{
 c000188:	e1a0c00d 	mov	ip, sp
 c00018c:	e92dd800 	push	{fp, ip, lr, pc}
 c000190:	e24cb004 	sub	fp, ip, #4
 c000194:	e24dd028 	sub	sp, sp, #40	; 0x28
 c000198:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
 c00019c:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
 c0001a0:	e50b2030 	str	r2, [fp, #-48]	; 0xffffffd0
 c0001a4:	e54b3031 	strb	r3, [fp, #-49]	; 0xffffffcf
	int displace = 3 + (int)valor;
 c0001a8:	e55b3031 	ldrb	r3, [fp, #-49]	; 0xffffffcf
 c0001ac:	e2833003 	add	r3, r3, #3
 c0001b0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    /* recorrer fila descartando el valor en la lista de candidatos */
    int col = 0;
 c0001b4:	e3a03000 	mov	r3, #0
 c0001b8:	e50b3010 	str	r3, [fp, #-16]
    while(col < NUM_COLUMNAS - 7){
 c0001bc:	ea000021 	b	c000248 <sudoku_candidatos_propagar_c+0xc0>
    	cuadricula[fila][col] &= ~(1 << displace);
 c0001c0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c0001c4:	e1a03283 	lsl	r3, r3, #5
 c0001c8:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c0001cc:	e0821003 	add	r1, r2, r3
 c0001d0:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c0001d4:	e1a03283 	lsl	r3, r3, #5
 c0001d8:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c0001dc:	e0822003 	add	r2, r2, r3
 c0001e0:	e51b3010 	ldr	r3, [fp, #-16]
 c0001e4:	e1a03083 	lsl	r3, r3, #1
 c0001e8:	e0823003 	add	r3, r2, r3
 c0001ec:	e1d330b0 	ldrh	r3, [r3]
 c0001f0:	e1a03803 	lsl	r3, r3, #16
 c0001f4:	e1a02823 	lsr	r2, r3, #16
 c0001f8:	e3a00001 	mov	r0, #1
 c0001fc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c000200:	e1a03310 	lsl	r3, r0, r3
 c000204:	e1a03803 	lsl	r3, r3, #16
 c000208:	e1a03823 	lsr	r3, r3, #16
 c00020c:	e1e03003 	mvn	r3, r3
 c000210:	e1a03803 	lsl	r3, r3, #16
 c000214:	e1a03823 	lsr	r3, r3, #16
 c000218:	e0023003 	and	r3, r2, r3
 c00021c:	e1a03803 	lsl	r3, r3, #16
 c000220:	e1a03823 	lsr	r3, r3, #16
 c000224:	e1a03803 	lsl	r3, r3, #16
 c000228:	e1a02823 	lsr	r2, r3, #16
 c00022c:	e51b3010 	ldr	r3, [fp, #-16]
 c000230:	e1a03083 	lsl	r3, r3, #1
 c000234:	e0813003 	add	r3, r1, r3
 c000238:	e1c320b0 	strh	r2, [r3]
    	col++;
 c00023c:	e51b3010 	ldr	r3, [fp, #-16]
 c000240:	e2833001 	add	r3, r3, #1
 c000244:	e50b3010 	str	r3, [fp, #-16]
{
	int displace = 3 + (int)valor;

    /* recorrer fila descartando el valor en la lista de candidatos */
    int col = 0;
    while(col < NUM_COLUMNAS - 7){
 c000248:	e51b3010 	ldr	r3, [fp, #-16]
 c00024c:	e3530008 	cmp	r3, #8
 c000250:	daffffda 	ble	c0001c0 <sudoku_candidatos_propagar_c+0x38>
    	cuadricula[fila][col] &= ~(1 << displace);
    	col++;
    }

    /* recorrer columna descartando el valor en la lista de candidatos */
    int row = 0;
 c000254:	e3a03000 	mov	r3, #0
 c000258:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    while(row < NUM_FILAS){
 c00025c:	ea000021 	b	c0002e8 <sudoku_candidatos_propagar_c+0x160>
    	cuadricula[row][columna] &= ~(1 << displace);
 c000260:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000264:	e1a03283 	lsl	r3, r3, #5
 c000268:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c00026c:	e0821003 	add	r1, r2, r3
 c000270:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000274:	e1a03283 	lsl	r3, r3, #5
 c000278:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c00027c:	e0822003 	add	r2, r2, r3
 c000280:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
 c000284:	e1a03083 	lsl	r3, r3, #1
 c000288:	e0823003 	add	r3, r2, r3
 c00028c:	e1d330b0 	ldrh	r3, [r3]
 c000290:	e1a03803 	lsl	r3, r3, #16
 c000294:	e1a02823 	lsr	r2, r3, #16
 c000298:	e3a00001 	mov	r0, #1
 c00029c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c0002a0:	e1a03310 	lsl	r3, r0, r3
 c0002a4:	e1a03803 	lsl	r3, r3, #16
 c0002a8:	e1a03823 	lsr	r3, r3, #16
 c0002ac:	e1e03003 	mvn	r3, r3
 c0002b0:	e1a03803 	lsl	r3, r3, #16
 c0002b4:	e1a03823 	lsr	r3, r3, #16
 c0002b8:	e0023003 	and	r3, r2, r3
 c0002bc:	e1a03803 	lsl	r3, r3, #16
 c0002c0:	e1a03823 	lsr	r3, r3, #16
 c0002c4:	e1a03803 	lsl	r3, r3, #16
 c0002c8:	e1a02823 	lsr	r2, r3, #16
 c0002cc:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
 c0002d0:	e1a03083 	lsl	r3, r3, #1
 c0002d4:	e0813003 	add	r3, r1, r3
 c0002d8:	e1c320b0 	strh	r2, [r3]
    	row++;
 c0002dc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0002e0:	e2833001 	add	r3, r3, #1
 c0002e4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    	col++;
    }

    /* recorrer columna descartando el valor en la lista de candidatos */
    int row = 0;
    while(row < NUM_FILAS){
 c0002e8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0002ec:	e3530008 	cmp	r3, #8
 c0002f0:	daffffda 	ble	c000260 <sudoku_candidatos_propagar_c+0xd8>
    	row++;
    }


    /*Calcular la posicion inicial para la region correspondiente*/
    int row_start = (fila / 3) * 3;
 c0002f4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c0002f8:	e59f211c 	ldr	r2, [pc, #284]	; c00041c <sudoku_candidatos_propagar_c+0x294>
 c0002fc:	e0c21293 	smull	r1, r2, r3, r2
 c000300:	e1a03fc3 	asr	r3, r3, #31
 c000304:	e0632002 	rsb	r2, r3, r2
 c000308:	e1a03002 	mov	r3, r2
 c00030c:	e1a03083 	lsl	r3, r3, #1
 c000310:	e0833002 	add	r3, r3, r2
 c000314:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    int col_start = (columna / 3) * 3;
 c000318:	e51b3030 	ldr	r3, [fp, #-48]	; 0xffffffd0
 c00031c:	e59f20f8 	ldr	r2, [pc, #248]	; c00041c <sudoku_candidatos_propagar_c+0x294>
 c000320:	e0c21293 	smull	r1, r2, r3, r2
 c000324:	e1a03fc3 	asr	r3, r3, #31
 c000328:	e0632002 	rsb	r2, r3, r2
 c00032c:	e1a03002 	mov	r3, r2
 c000330:	e1a03083 	lsl	r3, r3, #1
 c000334:	e0833002 	add	r3, r3, r2
 c000338:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc

    /* recorrer region descartando el valor en la lista de candidatos */
    row = row_start;
 c00033c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c000340:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    while(row < (row_start + 3)){
 c000344:	ea00002c 	b	c0003fc <sudoku_candidatos_propagar_c+0x274>
    	int col = col_start;
 c000348:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c00034c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    	while(col < (col_start + 3)){
 c000350:	ea000021 	b	c0003dc <sudoku_candidatos_propagar_c+0x254>
    		cuadricula[row][col] &= ~(1 << displace);
 c000354:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000358:	e1a03283 	lsl	r3, r3, #5
 c00035c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c000360:	e0821003 	add	r1, r2, r3
 c000364:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000368:	e1a03283 	lsl	r3, r3, #5
 c00036c:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c000370:	e0822003 	add	r2, r2, r3
 c000374:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000378:	e1a03083 	lsl	r3, r3, #1
 c00037c:	e0823003 	add	r3, r2, r3
 c000380:	e1d330b0 	ldrh	r3, [r3]
 c000384:	e1a03803 	lsl	r3, r3, #16
 c000388:	e1a02823 	lsr	r2, r3, #16
 c00038c:	e3a00001 	mov	r0, #1
 c000390:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c000394:	e1a03310 	lsl	r3, r0, r3
 c000398:	e1a03803 	lsl	r3, r3, #16
 c00039c:	e1a03823 	lsr	r3, r3, #16
 c0003a0:	e1e03003 	mvn	r3, r3
 c0003a4:	e1a03803 	lsl	r3, r3, #16
 c0003a8:	e1a03823 	lsr	r3, r3, #16
 c0003ac:	e0023003 	and	r3, r2, r3
 c0003b0:	e1a03803 	lsl	r3, r3, #16
 c0003b4:	e1a03823 	lsr	r3, r3, #16
 c0003b8:	e1a03803 	lsl	r3, r3, #16
 c0003bc:	e1a02823 	lsr	r2, r3, #16
 c0003c0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c0003c4:	e1a03083 	lsl	r3, r3, #1
 c0003c8:	e0813003 	add	r3, r1, r3
 c0003cc:	e1c320b0 	strh	r2, [r3]
    		col++;
 c0003d0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c0003d4:	e2833001 	add	r3, r3, #1
 c0003d8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    /* recorrer region descartando el valor en la lista de candidatos */
    row = row_start;
    while(row < (row_start + 3)){
    	int col = col_start;
    	while(col < (col_start + 3)){
 c0003dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c0003e0:	e2832003 	add	r2, r3, #3
 c0003e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c0003e8:	e1520003 	cmp	r2, r3
 c0003ec:	caffffd8 	bgt	c000354 <sudoku_candidatos_propagar_c+0x1cc>
    		cuadricula[row][col] &= ~(1 << displace);
    		col++;
    	}
    	row++;
 c0003f0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0003f4:	e2833001 	add	r3, r3, #1
 c0003f8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    int row_start = (fila / 3) * 3;
    int col_start = (columna / 3) * 3;

    /* recorrer region descartando el valor en la lista de candidatos */
    row = row_start;
    while(row < (row_start + 3)){
 c0003fc:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c000400:	e2832003 	add	r2, r3, #3
 c000404:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000408:	e1520003 	cmp	r2, r3
 c00040c:	caffffcd 	bgt	c000348 <sudoku_candidatos_propagar_c+0x1c0>
    		cuadricula[row][col] &= ~(1 << displace);
    		col++;
    	}
    	row++;
    }
}
 c000410:	e24bd00c 	sub	sp, fp, #12
 c000414:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000418:	e12fff1e 	bx	lr
 c00041c:	55555556 	.word	0x55555556

0c000420 <init_candidatos>:

void
init_candidatos(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS]){
 c000420:	e1a0c00d 	mov	ip, sp
 c000424:	e92dd800 	push	{fp, ip, lr, pc}
 c000428:	e24cb004 	sub	fp, ip, #4
 c00042c:	e24dd018 	sub	sp, sp, #24
 c000430:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
	int row=0;
 c000434:	e3a03000 	mov	r3, #0
 c000438:	e50b3010 	str	r3, [fp, #-16]
	while(row < NUM_FILAS){
 c00043c:	ea00002e 	b	c0004fc <init_candidatos+0xdc>
		int col=0;
 c000440:	e3a03000 	mov	r3, #0
 c000444:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(col < NUM_COLUMNAS - 7){
 c000448:	ea000025 	b	c0004e4 <init_candidatos+0xc4>

			uint8_t valor_actual = celda_leer_valor(cuadricula[row][col]);
 c00044c:	e51b3010 	ldr	r3, [fp, #-16]
 c000450:	e1a03283 	lsl	r3, r3, #5
 c000454:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c000458:	e0822003 	add	r2, r2, r3
 c00045c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000460:	e1a03083 	lsl	r3, r3, #1
 c000464:	e0823003 	add	r3, r2, r3
 c000468:	e1d330b0 	ldrh	r3, [r3]
 c00046c:	e1a00003 	mov	r0, r3
 c000470:	ebffff2a 	bl	c000120 <celda_leer_valor>
 c000474:	e1a03000 	mov	r3, r0
 c000478:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb

			if(valor_actual == 0){
 c00047c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c000480:	e3530000 	cmp	r3, #0
 c000484:	1a000013 	bne	c0004d8 <init_candidatos+0xb8>
				cuadricula[row][col] |= 0x1FF0;
 c000488:	e51b3010 	ldr	r3, [fp, #-16]
 c00048c:	e1a03283 	lsl	r3, r3, #5
 c000490:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c000494:	e0821003 	add	r1, r2, r3
 c000498:	e51b3010 	ldr	r3, [fp, #-16]
 c00049c:	e1a03283 	lsl	r3, r3, #5
 c0004a0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c0004a4:	e0822003 	add	r2, r2, r3
 c0004a8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0004ac:	e1a03083 	lsl	r3, r3, #1
 c0004b0:	e0823003 	add	r3, r2, r3
 c0004b4:	e1d330b0 	ldrh	r3, [r3]
 c0004b8:	e3833d7f 	orr	r3, r3, #8128	; 0x1fc0
 c0004bc:	e3833030 	orr	r3, r3, #48	; 0x30
 c0004c0:	e1a03803 	lsl	r3, r3, #16
 c0004c4:	e1a02823 	lsr	r2, r3, #16
 c0004c8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0004cc:	e1a03083 	lsl	r3, r3, #1
 c0004d0:	e0813003 	add	r3, r1, r3
 c0004d4:	e1c320b0 	strh	r2, [r3]
			}
			col++;
 c0004d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0004dc:	e2833001 	add	r3, r3, #1
 c0004e0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
void
init_candidatos(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS]){
	int row=0;
	while(row < NUM_FILAS){
		int col=0;
		while(col < NUM_COLUMNAS - 7){
 c0004e4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0004e8:	e3530008 	cmp	r3, #8
 c0004ec:	daffffd6 	ble	c00044c <init_candidatos+0x2c>
			if(valor_actual == 0){
				cuadricula[row][col] |= 0x1FF0;
			}
			col++;
		}
		row++;
 c0004f0:	e51b3010 	ldr	r3, [fp, #-16]
 c0004f4:	e2833001 	add	r3, r3, #1
 c0004f8:	e50b3010 	str	r3, [fp, #-16]
}

void
init_candidatos(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS]){
	int row=0;
	while(row < NUM_FILAS){
 c0004fc:	e51b3010 	ldr	r3, [fp, #-16]
 c000500:	e3530008 	cmp	r3, #8
 c000504:	daffffcd 	ble	c000440 <init_candidatos+0x20>
			}
			col++;
		}
		row++;
	}
}
 c000508:	e24bd00c 	sub	sp, fp, #12
 c00050c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000510:	e12fff1e 	bx	lr

0c000514 <propagar_if_value>:

void
propagar_if_value(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int *celdas_vacias){
 c000514:	e1a0c00d 	mov	ip, sp
 c000518:	e92dd800 	push	{fp, ip, lr, pc}
 c00051c:	e24cb004 	sub	fp, ip, #4
 c000520:	e24dd018 	sub	sp, sp, #24
 c000524:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c000528:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
	int row=0;
 c00052c:	e3a03000 	mov	r3, #0
 c000530:	e50b3010 	str	r3, [fp, #-16]
	while(row < NUM_FILAS){
 c000534:	ea00002b 	b	c0005e8 <propagar_if_value+0xd4>
		int col=0;
 c000538:	e3a03000 	mov	r3, #0
 c00053c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(col < NUM_COLUMNAS - 7){
 c000540:	ea000022 	b	c0005d0 <propagar_if_value+0xbc>
			uint8_t celda_actual = cuadricula[row][col];
 c000544:	e51b3010 	ldr	r3, [fp, #-16]
 c000548:	e1a03283 	lsl	r3, r3, #5
 c00054c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
 c000550:	e0822003 	add	r2, r2, r3
 c000554:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000558:	e1a03083 	lsl	r3, r3, #1
 c00055c:	e0823003 	add	r3, r2, r3
 c000560:	e1d330b0 	ldrh	r3, [r3]
 c000564:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
			uint8_t valor_actual = celda_leer_valor(celda_actual);
 c000568:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
 c00056c:	e1a03803 	lsl	r3, r3, #16
 c000570:	e1a03823 	lsr	r3, r3, #16
 c000574:	e1a00003 	mov	r0, r3
 c000578:	ebfffee8 	bl	c000120 <celda_leer_valor>
 c00057c:	e1a03000 	mov	r3, r0
 c000580:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
			if(valor_actual == 0x0000){
 c000584:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c000588:	e3530000 	cmp	r3, #0
 c00058c:	1a000005 	bne	c0005a8 <propagar_if_value+0x94>
				(*celdas_vacias)++;
 c000590:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c000594:	e5933000 	ldr	r3, [r3]
 c000598:	e2832001 	add	r2, r3, #1
 c00059c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c0005a0:	e5832000 	str	r2, [r3]
 c0005a4:	ea000006 	b	c0005c4 <propagar_if_value+0xb0>
			} else {
				sudoku_candidatos_propagar_arm(cuadricula, row, col, valor_actual);
 c0005a8:	e51b3010 	ldr	r3, [fp, #-16]
 c0005ac:	e20310ff 	and	r1, r3, #255	; 0xff
 c0005b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0005b4:	e20320ff 	and	r2, r3, #255	; 0xff
 c0005b8:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
 c0005bc:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c0005c0:	ebfffe8e 	bl	c000000 <sudoku_candidatos_propagar_arm>
				//sudoku_candidatos_propagar_c(cuadricula,row,col,valor_actual);
			}
			col++;
 c0005c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0005c8:	e2833001 	add	r3, r3, #1
 c0005cc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
void
propagar_if_value(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int *celdas_vacias){
	int row=0;
	while(row < NUM_FILAS){
		int col=0;
		while(col < NUM_COLUMNAS - 7){
 c0005d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0005d4:	e3530008 	cmp	r3, #8
 c0005d8:	daffffd9 	ble	c000544 <propagar_if_value+0x30>
				sudoku_candidatos_propagar_arm(cuadricula, row, col, valor_actual);
				//sudoku_candidatos_propagar_c(cuadricula,row,col,valor_actual);
			}
			col++;
		}
		row++;
 c0005dc:	e51b3010 	ldr	r3, [fp, #-16]
 c0005e0:	e2833001 	add	r3, r3, #1
 c0005e4:	e50b3010 	str	r3, [fp, #-16]
}

void
propagar_if_value(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int *celdas_vacias){
	int row=0;
	while(row < NUM_FILAS){
 c0005e8:	e51b3010 	ldr	r3, [fp, #-16]
 c0005ec:	e3530008 	cmp	r3, #8
 c0005f0:	daffffd0 	ble	c000538 <propagar_if_value+0x24>
			}
			col++;
		}
		row++;
	}
}
 c0005f4:	e24bd00c 	sub	sp, fp, #12
 c0005f8:	e89d6800 	ldm	sp, {fp, sp, lr}
 c0005fc:	e12fff1e 	bx	lr

0c000600 <sudoku_candidatos_init_c>:
 * calcula todas las listas de candidatos (9x9)
 * necesario tras borrar o cambiar un valor (listas corrompidas)
 * retorna el numero de celdas vacias */
static int
sudoku_candidatos_init_c(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS])
{
 c000600:	e1a0c00d 	mov	ip, sp
 c000604:	e92dd800 	push	{fp, ip, lr, pc}
 c000608:	e24cb004 	sub	fp, ip, #4
 c00060c:	e24dd010 	sub	sp, sp, #16
 c000610:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 	int celdas_vacias = 0;
 c000614:	e3a03000 	mov	r3, #0
 c000618:	e50b3010 	str	r3, [fp, #-16]
	/*TODO: inicializa lista de candidatos */
    init_candidatos(cuadricula);
 c00061c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000620:	ebffff7e 	bl	c000420 <init_candidatos>

    /* TODO: propagar si la celda tiene valor*/
    propagar_if_value(cuadricula, &celdas_vacias);
 c000624:	e24b3010 	sub	r3, fp, #16
 c000628:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c00062c:	e1a01003 	mov	r1, r3
 c000630:	ebffffb7 	bl	c000514 <propagar_if_value>

    return celdas_vacias;
 c000634:	e51b3010 	ldr	r3, [fp, #-16]
}
 c000638:	e1a00003 	mov	r0, r3
 c00063c:	e24bd00c 	sub	sp, fp, #12
 c000640:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000644:	e12fff1e 	bx	lr

0c000648 <cuadricula_candidatos_verificar>:


static void
cuadricula_candidatos_verificar(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS],int row, int col, int *errors){
 c000648:	e1a0c00d 	mov	ip, sp
 c00064c:	e92dd800 	push	{fp, ip, lr, pc}
 c000650:	e24cb004 	sub	fp, ip, #4
 c000654:	e24dd038 	sub	sp, sp, #56	; 0x38
 c000658:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
 c00065c:	e50b103c 	str	r1, [fp, #-60]	; 0xffffffc4
 c000660:	e50b2040 	str	r2, [fp, #-64]	; 0xffffffc0
 c000664:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc

	uint8_t valor = celda_leer_valor(cuadricula[row][col]);
 c000668:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c00066c:	e1a03283 	lsl	r3, r3, #5
 c000670:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000674:	e0822003 	add	r2, r2, r3
 c000678:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c00067c:	e1a03083 	lsl	r3, r3, #1
 c000680:	e0823003 	add	r3, r2, r3
 c000684:	e1d330b0 	ldrh	r3, [r3]
 c000688:	e1a00003 	mov	r0, r3
 c00068c:	ebfffea3 	bl	c000120 <celda_leer_valor>
 c000690:	e1a03000 	mov	r3, r0
 c000694:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

	if(valor != 0x0000){
 c000698:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c00069c:	e3530000 	cmp	r3, #0
 c0006a0:	0a0000b2 	beq	c000970 <cuadricula_candidatos_verificar+0x328>
		int displace = 3 + (int)valor;
 c0006a4:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c0006a8:	e2833003 	add	r3, r3, #3
 c0006ac:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

		//Verificar el valor en toda la fila (Horizontal)
		int j = 0;
 c0006b0:	e3a03000 	mov	r3, #0
 c0006b4:	e50b3010 	str	r3, [fp, #-16]
		while( j < NUM_COLUMNAS - 7){
 c0006b8:	ea000028 	b	c000760 <cuadricula_candidatos_verificar+0x118>
			uint8_t is_bit_set = cuadricula[row][j] & (1 << displace);
 c0006bc:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c0006c0:	e1a03283 	lsl	r3, r3, #5
 c0006c4:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c0006c8:	e0822003 	add	r2, r2, r3
 c0006cc:	e51b3010 	ldr	r3, [fp, #-16]
 c0006d0:	e1a03083 	lsl	r3, r3, #1
 c0006d4:	e0823003 	add	r3, r2, r3
 c0006d8:	e1d330b0 	ldrh	r3, [r3]
 c0006dc:	e20320ff 	and	r2, r3, #255	; 0xff
 c0006e0:	e3a01001 	mov	r1, #1
 c0006e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c0006e8:	e1a03311 	lsl	r3, r1, r3
 c0006ec:	e20330ff 	and	r3, r3, #255	; 0xff
 c0006f0:	e0023003 	and	r3, r2, r3
 c0006f4:	e20330ff 	and	r3, r3, #255	; 0xff
 c0006f8:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf

			if(j != col && is_bit_set){
 c0006fc:	e51b2010 	ldr	r2, [fp, #-16]
 c000700:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c000704:	e1520003 	cmp	r2, r3
 c000708:	0a000011 	beq	c000754 <cuadricula_candidatos_verificar+0x10c>
 c00070c:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c000710:	e3530000 	cmp	r3, #0
 c000714:	0a00000e 	beq	c000754 <cuadricula_candidatos_verificar+0x10c>
				activar_error(cuadricula[row][j]);
 c000718:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c00071c:	e1a03283 	lsl	r3, r3, #5
 c000720:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000724:	e0822003 	add	r2, r2, r3
 c000728:	e51b3010 	ldr	r3, [fp, #-16]
 c00072c:	e1a03083 	lsl	r3, r3, #1
 c000730:	e0823003 	add	r3, r2, r3
 c000734:	e1d330b0 	ldrh	r3, [r3]
 c000738:	e1a00003 	mov	r0, r3
 c00073c:	ebfffe85 	bl	c000158 <activar_error>
				(*errors)++;
 c000740:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000744:	e5933000 	ldr	r3, [r3]
 c000748:	e2832001 	add	r2, r3, #1
 c00074c:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000750:	e5832000 	str	r2, [r3]
			}
			j++;
 c000754:	e51b3010 	ldr	r3, [fp, #-16]
 c000758:	e2833001 	add	r3, r3, #1
 c00075c:	e50b3010 	str	r3, [fp, #-16]
	if(valor != 0x0000){
		int displace = 3 + (int)valor;

		//Verificar el valor en toda la fila (Horizontal)
		int j = 0;
		while( j < NUM_COLUMNAS - 7){
 c000760:	e51b3010 	ldr	r3, [fp, #-16]
 c000764:	e3530008 	cmp	r3, #8
 c000768:	daffffd3 	ble	c0006bc <cuadricula_candidatos_verificar+0x74>
			}
			j++;
		}

		//Verificar el valor en toda la columna (Vertical)
		int i = 0;
 c00076c:	e3a03000 	mov	r3, #0
 c000770:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(i < NUM_FILAS){
 c000774:	ea000028 	b	c00081c <cuadricula_candidatos_verificar+0x1d4>
			uint8_t is_bit_set = cuadricula[i][col] & (1 << displace);
 c000778:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c00077c:	e1a03283 	lsl	r3, r3, #5
 c000780:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000784:	e0822003 	add	r2, r2, r3
 c000788:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c00078c:	e1a03083 	lsl	r3, r3, #1
 c000790:	e0823003 	add	r3, r2, r3
 c000794:	e1d330b0 	ldrh	r3, [r3]
 c000798:	e20320ff 	and	r2, r3, #255	; 0xff
 c00079c:	e3a01001 	mov	r1, #1
 c0007a0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c0007a4:	e1a03311 	lsl	r3, r1, r3
 c0007a8:	e20330ff 	and	r3, r3, #255	; 0xff
 c0007ac:	e0023003 	and	r3, r2, r3
 c0007b0:	e20330ff 	and	r3, r3, #255	; 0xff
 c0007b4:	e54b3022 	strb	r3, [fp, #-34]	; 0xffffffde
			if(i != row && is_bit_set){
 c0007b8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c0007bc:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c0007c0:	e1520003 	cmp	r2, r3
 c0007c4:	0a000011 	beq	c000810 <cuadricula_candidatos_verificar+0x1c8>
 c0007c8:	e55b3022 	ldrb	r3, [fp, #-34]	; 0xffffffde
 c0007cc:	e3530000 	cmp	r3, #0
 c0007d0:	0a00000e 	beq	c000810 <cuadricula_candidatos_verificar+0x1c8>
				activar_error(cuadricula[i][col]);
 c0007d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0007d8:	e1a03283 	lsl	r3, r3, #5
 c0007dc:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c0007e0:	e0822003 	add	r2, r2, r3
 c0007e4:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c0007e8:	e1a03083 	lsl	r3, r3, #1
 c0007ec:	e0823003 	add	r3, r2, r3
 c0007f0:	e1d330b0 	ldrh	r3, [r3]
 c0007f4:	e1a00003 	mov	r0, r3
 c0007f8:	ebfffe56 	bl	c000158 <activar_error>
				(*errors)++;
 c0007fc:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000800:	e5933000 	ldr	r3, [r3]
 c000804:	e2832001 	add	r2, r3, #1
 c000808:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c00080c:	e5832000 	str	r2, [r3]
			}
			i++;
 c000810:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000814:	e2833001 	add	r3, r3, #1
 c000818:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
			j++;
		}

		//Verificar el valor en toda la columna (Vertical)
		int i = 0;
		while(i < NUM_FILAS){
 c00081c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000820:	e3530008 	cmp	r3, #8
 c000824:	daffffd3 	ble	c000778 <cuadricula_candidatos_verificar+0x130>
			}
			i++;
		}

		/*Calcular la posicion inicial para seccion correspondiente a la ubicacion actual*/
		int row_start = (row / 3) * 3;
 c000828:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c00082c:	e59f2148 	ldr	r2, [pc, #328]	; c00097c <cuadricula_candidatos_verificar+0x334>
 c000830:	e0c21293 	smull	r1, r2, r3, r2
 c000834:	e1a03fc3 	asr	r3, r3, #31
 c000838:	e0632002 	rsb	r2, r3, r2
 c00083c:	e1a03002 	mov	r3, r2
 c000840:	e1a03083 	lsl	r3, r3, #1
 c000844:	e0833002 	add	r3, r3, r2
 c000848:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
		int col_start = (col / 3) * 3;
 c00084c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c000850:	e59f2124 	ldr	r2, [pc, #292]	; c00097c <cuadricula_candidatos_verificar+0x334>
 c000854:	e0c21293 	smull	r1, r2, r3, r2
 c000858:	e1a03fc3 	asr	r3, r3, #31
 c00085c:	e0632002 	rsb	r2, r3, r2
 c000860:	e1a03002 	mov	r3, r2
 c000864:	e1a03083 	lsl	r3, r3, #1
 c000868:	e0833002 	add	r3, r3, r2
 c00086c:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4

		//Verificar valor en la seccion (cuadro 3x3)
		i = row_start;
 c000870:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c000874:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(i < (row_start + 3)){
 c000878:	ea000037 	b	c00095c <cuadricula_candidatos_verificar+0x314>
			int j = col_start;
 c00087c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c000880:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
			while(j < (col_start + 3)){
 c000884:	ea00002c 	b	c00093c <cuadricula_candidatos_verificar+0x2f4>
				uint8_t is_bit_set = cuadricula[i][j] & (1 << displace);
 c000888:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c00088c:	e1a03283 	lsl	r3, r3, #5
 c000890:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000894:	e0822003 	add	r2, r2, r3
 c000898:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c00089c:	e1a03083 	lsl	r3, r3, #1
 c0008a0:	e0823003 	add	r3, r2, r3
 c0008a4:	e1d330b0 	ldrh	r3, [r3]
 c0008a8:	e20320ff 	and	r2, r3, #255	; 0xff
 c0008ac:	e3a01001 	mov	r1, #1
 c0008b0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c0008b4:	e1a03311 	lsl	r3, r1, r3
 c0008b8:	e20330ff 	and	r3, r3, #255	; 0xff
 c0008bc:	e0023003 	and	r3, r2, r3
 c0008c0:	e20330ff 	and	r3, r3, #255	; 0xff
 c0008c4:	e54b302d 	strb	r3, [fp, #-45]	; 0xffffffd3
				if((i != row_start || j != col_start) && is_bit_set){
 c0008c8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c0008cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c0008d0:	e1520003 	cmp	r2, r3
 c0008d4:	1a000003 	bne	c0008e8 <cuadricula_candidatos_verificar+0x2a0>
 c0008d8:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c0008dc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c0008e0:	e1520003 	cmp	r2, r3
 c0008e4:	0a000011 	beq	c000930 <cuadricula_candidatos_verificar+0x2e8>
 c0008e8:	e55b302d 	ldrb	r3, [fp, #-45]	; 0xffffffd3
 c0008ec:	e3530000 	cmp	r3, #0
 c0008f0:	0a00000e 	beq	c000930 <cuadricula_candidatos_verificar+0x2e8>
					activar_error(cuadricula[i][j]);
 c0008f4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0008f8:	e1a03283 	lsl	r3, r3, #5
 c0008fc:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000900:	e0822003 	add	r2, r2, r3
 c000904:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000908:	e1a03083 	lsl	r3, r3, #1
 c00090c:	e0823003 	add	r3, r2, r3
 c000910:	e1d330b0 	ldrh	r3, [r3]
 c000914:	e1a00003 	mov	r0, r3
 c000918:	ebfffe0e 	bl	c000158 <activar_error>
					(*errors)++;
 c00091c:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000920:	e5933000 	ldr	r3, [r3]
 c000924:	e2832001 	add	r2, r3, #1
 c000928:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c00092c:	e5832000 	str	r2, [r3]
				}
				j++;
 c000930:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000934:	e2833001 	add	r3, r3, #1
 c000938:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

		//Verificar valor en la seccion (cuadro 3x3)
		i = row_start;
		while(i < (row_start + 3)){
			int j = col_start;
			while(j < (col_start + 3)){
 c00093c:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c000940:	e2832003 	add	r2, r3, #3
 c000944:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000948:	e1520003 	cmp	r2, r3
 c00094c:	caffffcd 	bgt	c000888 <cuadricula_candidatos_verificar+0x240>
					activar_error(cuadricula[i][j]);
					(*errors)++;
				}
				j++;
			}
			i++;
 c000950:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000954:	e2833001 	add	r3, r3, #1
 c000958:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		int row_start = (row / 3) * 3;
		int col_start = (col / 3) * 3;

		//Verificar valor en la seccion (cuadro 3x3)
		i = row_start;
		while(i < (row_start + 3)){
 c00095c:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c000960:	e2832003 	add	r2, r3, #3
 c000964:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000968:	e1520003 	cmp	r2, r3
 c00096c:	caffffc2 	bgt	c00087c <cuadricula_candidatos_verificar+0x234>
				j++;
			}
			i++;
		}
	}
}
 c000970:	e24bd00c 	sub	sp, fp, #12
 c000974:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000978:	e12fff1e 	bx	lr
 c00097c:	55555556 	.word	0x55555556

0c000980 <sudoku9x9>:
/* *******************************************cuadricula[NUM_FILAS][NUM_COLUMNAS]**********************************
 * programa principal del juego que recibe el tablero,
 * y la senyal de ready que indica que se han actualizado fila y columna */
void
sudoku9x9(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], char *ready)
{
 c000980:	e1a0c00d 	mov	ip, sp
 c000984:	e92dd800 	push	{fp, ip, lr, pc}
 c000988:	e24cb004 	sub	fp, ip, #4
 c00098c:	e24dd018 	sub	sp, sp, #24
 c000990:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
 c000994:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
    int celdas_vacias;

    /* calcula lista de candidatos, versi—n C */
    celdas_vacias = sudoku_candidatos_init_c(cuadricula);
 c000998:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c00099c:	ebffff17 	bl	c000600 <sudoku_candidatos_init_c>
 c0009a0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8

    /* verificar que la lista de candidatos calculada es correcta */
    int errors = 0;
 c0009a4:	e3a03000 	mov	r3, #0
 c0009a8:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
    int row = 0;
 c0009ac:	e3a03000 	mov	r3, #0
 c0009b0:	e50b3010 	str	r3, [fp, #-16]
    while(row < NUM_FILAS){
 c0009b4:	ea000010 	b	c0009fc <sudoku9x9+0x7c>
		int col = 0;
 c0009b8:	e3a03000 	mov	r3, #0
 c0009bc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    	while(col < NUM_COLUMNAS - 7){
 c0009c0:	ea000007 	b	c0009e4 <sudoku9x9+0x64>
    		cuadricula_candidatos_verificar(cuadricula, row, col, &errors);
 c0009c4:	e24b301c 	sub	r3, fp, #28
 c0009c8:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c0009cc:	e51b1010 	ldr	r1, [fp, #-16]
 c0009d0:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c0009d4:	ebffff1b 	bl	c000648 <cuadricula_candidatos_verificar>
    		col++;
 c0009d8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0009dc:	e2833001 	add	r3, r3, #1
 c0009e0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    /* verificar que la lista de candidatos calculada es correcta */
    int errors = 0;
    int row = 0;
    while(row < NUM_FILAS){
		int col = 0;
    	while(col < NUM_COLUMNAS - 7){
 c0009e4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0009e8:	e3530008 	cmp	r3, #8
 c0009ec:	dafffff4 	ble	c0009c4 <sudoku9x9+0x44>
    		cuadricula_candidatos_verificar(cuadricula, row, col, &errors);
    		col++;
    	}
    	row++;
 c0009f0:	e51b3010 	ldr	r3, [fp, #-16]
 c0009f4:	e2833001 	add	r3, r3, #1
 c0009f8:	e50b3010 	str	r3, [fp, #-16]
    celdas_vacias = sudoku_candidatos_init_c(cuadricula);

    /* verificar que la lista de candidatos calculada es correcta */
    int errors = 0;
    int row = 0;
    while(row < NUM_FILAS){
 c0009fc:	e51b3010 	ldr	r3, [fp, #-16]
 c000a00:	e3530008 	cmp	r3, #8
 c000a04:	daffffeb 	ble	c0009b8 <sudoku9x9+0x38>
    		col++;
    	}
    	row++;
    }
    /* repetir para otras versiones (C optimizado, ARM, THUMB) */
}
 c000a08:	e24bd00c 	sub	sp, fp, #12
 c000a0c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000a10:	e12fff1e 	bx	lr
