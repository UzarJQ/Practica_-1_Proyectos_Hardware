
PH_Sudoku.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c98  0c000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000120  0c000ca0  0c000ca0  00008ca0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  2 .ARM.attributes 0000002e  00000000  00000000  00008dc0  2**0
                  CONTENTS, READONLY
  3 .comment      0000002a  00000000  00000000  00008dee  2**0
                  CONTENTS, READONLY
  4 .debug_line   000005b5  00000000  00000000  00008e18  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000004ef  00000000  00000000  000093cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000126  00000000  00000000  000098bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000040  00000000  00000000  000099e8  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_macinfo 00006574  00000000  00000000  00009a28  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000134  00000000  00000000  0000ff9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubnames 00000041  00000000  00000000  000100d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubtypes 00000035  00000000  00000000  00010111  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000001e5  00000000  00000000  00010146  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000000f0  00000000  00000000  0001032c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0c000000 <sudoku_candidatos_propagar_thumb>:
    @ r4 = desplazamiento de la fila
    @ r5 = desplazamiento de la columna
    @ r6 = bit desplazado (se usara para desactivar los candidatos)
    @ r7 = desplazamiento total (r4 + r5)

    movs r6, #0							@ Inicializar contador de celdas vacías a 0
 c000000:	2600      	movs	r6, #0

0c000002 <thumb_loop_i>:

thumb_loop_i:
    cmp r1, #9
 c000002:	2909      	cmp	r1, #9
    bge thumb_loop_i_end
 c000004:	da22      	bge.n	c00004c <thumb_loop_i_end>

    lsl r4, r1, #5						@ Desplazamiento a siguiente fila (r1 * 32 bytes)
 c000006:	014c      	lsls	r4, r1, #5

    mov r3, #0
 c000008:	2300      	movs	r3, #0

0c00000a <thumb_loop_j>:
thumb_loop_j:
    cmp r2, #9
 c00000a:	2a09      	cmp	r2, #9
    bge thumb_loop_j_end
 c00000c:	da1c      	bge.n	c000048 <thumb_loop_j_end>

    lsl r5, r2, #1						@ Desplazamiento a siguiente columna (r2 * 2 bytes)
 c00000e:	0055      	lsls	r5, r2, #1

    add r7, r4, r5                      @ Desplazamiento total (fila + columna)
 c000010:	1967      	adds	r7, r4, r5
    ldrh r3, [r0, r7]
 c000012:	5bc3      	ldrh	r3, [r0, r7]

	push {r6, lr}
 c000014:	b540      	push	{r6, lr}

	mov r6, #7
 c000016:	2607      	movs	r6, #7
    and r3, r3, r6						@ Obtener valor actual de la celda
 c000018:	4033      	ands	r3, r6
    cmp r3, #0							@ Si valor == 0, aumentar celdas vacías y omitir propagación
 c00001a:	2b00      	cmp	r3, #0
    beq empty_cell_t
 c00001c:	d00f      	beq.n	c00003e <empty_cell_t>

    add r3, #3                      	@ r8 = displace = (3 + r3)
 c00001e:	3303      	adds	r3, #3
    mov r6, #1
 c000020:	2601      	movs	r6, #1
    lsl r6, r6, r3						@ Desplazar bit a la izquierda r3 posiciones
 c000022:	409e      	lsls	r6, r3

    push {r1, r2, lr}					@ Guardar índices de fila y columna, y el contador de celdas vacías
 c000024:	b506      	push	{r1, r2, lr}

    bl update_row_candidates_thumb
 c000026:	f000 f813 	bl	c000050 <update_row_candidates_thumb>
    bl update_column_candidates_thumb
 c00002a:	f000 f81c 	bl	c000066 <update_column_candidates_thumb>

    pop {r1, r2, pc}
 c00002e:	bd06      	pop	{r1, r2, pc}

	push {r1, r2, lr}
 c000030:	b506      	push	{r1, r2, lr}

    bl calc_region_indexes_thumb
 c000032:	f000 f823 	bl	c00007c <calc_region_indexes_thumb>
    bl update_region_candidates_thumb
 c000036:	f000 f834 	bl	c0000a2 <region_row_loop_t>

    pop {r1, r2, pc}				@ Restaurar índices y contador de celdas vacías
 c00003a:	bd06      	pop	{r1, r2, pc}
    b next_column_t
 c00003c:	e002      	b.n	c000044 <next_column_t>

0c00003e <empty_cell_t>:

empty_cell_t:
	pop {r6, pc}
 c00003e:	bd40      	pop	{r6, pc}
    add r6, r6, #1
 c000040:	3601      	adds	r6, #1
    b next_column_t
 c000042:	e7ff      	b.n	c000044 <next_column_t>

0c000044 <next_column_t>:

next_column_t:
    add r2, r2, #1
 c000044:	3201      	adds	r2, #1
    b thumb_loop_j
 c000046:	e7e0      	b.n	c00000a <thumb_loop_j>

0c000048 <thumb_loop_j_end>:

thumb_loop_j_end:
    add r1, r1, #1
 c000048:	3101      	adds	r1, #1
    b thumb_loop_i
 c00004a:	e7da      	b.n	c000002 <thumb_loop_i>

0c00004c <thumb_loop_i_end>:

thumb_loop_i_end:
    mov r0, r10                          @ Almacenar el contador de celdas vacías en r0 para devolverlo como resultado
 c00004c:	4650      	mov	r0, sl
    bx lr
 c00004e:	4770      	bx	lr

0c000050 <update_row_candidates_thumb>:

update_row_candidates_thumb:
    movs r1, #0
 c000050:	2100      	movs	r1, #0

0c000052 <fila_loop_t>:
fila_loop_t:
    cmp r1, #9
 c000052:	2909      	cmp	r1, #9
    bge fin_fila_t
 c000054:	da06      	bge.n	c000064 <fin_fila_t>

    lsl r2, r1, #5                   @ Desplazar la fila (r8 * 32)
 c000056:	014a      	lsls	r2, r1, #5
    add r7, r2, r5                  @ r10 = desplazamiento total = fila + columna (columna fija para r5)
 c000058:	1957      	adds	r7, r2, r5

    ldrh r3, [r0, r7]
 c00005a:	5bc3      	ldrh	r3, [r0, r7]

    bic r3, r3, r6                   @ celda &= ~(1 << displace) - Actualizar el bit candidato
 c00005c:	43b3      	bics	r3, r6
    strh r3, [r0, r7]
 c00005e:	53c3      	strh	r3, [r0, r7]

    add r1, r1, #1
 c000060:	3101      	adds	r1, #1
    b fila_loop_t
 c000062:	e7f6      	b.n	c000052 <fila_loop_t>

0c000064 <fin_fila_t>:

fin_fila_t:
    bx lr
 c000064:	4770      	bx	lr

0c000066 <update_column_candidates_thumb>:

update_column_candidates_thumb:
    movs r1, #0
 c000066:	2100      	movs	r1, #0

0c000068 <col_loop_t>:
col_loop_t:
    cmp r1, #9
 c000068:	2909      	cmp	r1, #9
    bge fin_col_t
 c00006a:	da06      	bge.n	c00007a <fin_col_t>

    lsl r2, r1, #1                   @ Desplazar la columna (r8 * 2)
 c00006c:	004a      	lsls	r2, r1, #1
    add r7, r4, r2                  	@ r10 = desplazamiento total = fila + columna (fila fija para r4)
 c00006e:	18a7      	adds	r7, r4, r2

    ldrh r3, [r0, r7]
 c000070:	5bc3      	ldrh	r3, [r0, r7]

    bic r3, r3, r6                   @ celda &= ~(1 << displace) - Actualizar el bit candidato
 c000072:	43b3      	bics	r3, r6
    strh r3, [r0, r7]
 c000074:	53c3      	strh	r3, [r0, r7]

    add r1, r1, #1
 c000076:	3101      	adds	r1, #1
    b col_loop_t
 c000078:	e7f6      	b.n	c000068 <col_loop_t>

0c00007a <fin_col_t>:

fin_col_t:
    bx lr
 c00007a:	4770      	bx	lr

0c00007c <calc_region_indexes_thumb>:

calc_region_indexes_thumb:
    mov r3, r2
 c00007c:	1c13      	adds	r3, r2, #0
    mov r5, #0
 c00007e:	2500      	movs	r5, #0

0c000080 <col_index_t>:
col_index_t:
    cmp r3, #3                        @ Si es menor a 3, termina el cálculo de columna
 c000080:	2b03      	cmp	r3, #3
    blt col_index_end_t
 c000082:	db02      	blt.n	c00008a <col_index_end_t>

    sub r3, r3, #3                    @ Restas sucesivas para determinar la region de la celda (1°,2° o 3° region horizontal)
 c000084:	3b03      	subs	r3, #3
    add r5, r5, #3                    @ Aumentar #3 para ubicarse al inicio de la región correspondiente
 c000086:	3503      	adds	r5, #3
    b col_index_t
 c000088:	e7fa      	b.n	c000080 <col_index_t>

0c00008a <col_index_end_t>:

col_index_end_t:
    movs r2, r5                       @ Guardar el índice calculado en r2 (columna)
 c00008a:	1c2a      	adds	r2, r5, #0

    movs r3, r1
 c00008c:	1c0b      	adds	r3, r1, #0
    movs r4, #0
 c00008e:	2400      	movs	r4, #0

0c000090 <row_index_t>:
row_index_t:
    cmp r3, #3                        @ Si es menor a 3, termina el cálculo de fila
 c000090:	2b03      	cmp	r3, #3
    blt row_index_end_t
 c000092:	db02      	blt.n	c00009a <row_index_end_t>
    sub r3, r3, #3                    @ Restas sucesivas para determinar la región de la celda (1°,2° o 3° region vertical)
 c000094:	3b03      	subs	r3, #3
    add r4, r4, #3                    @ Aumentar #3 para ubicarse al inicio de la región correspondiente
 c000096:	3403      	adds	r4, #3
    b row_index_t
 c000098:	e7fa      	b.n	c000090 <row_index_t>

0c00009a <row_index_end_t>:

row_index_end_t:
    movs r1, r4                       @ Guardar el índice calculado en r1 (fila)
 c00009a:	1c21      	adds	r1, r4, #0

    add r4, r1, #3                    @ r4 = Límite superior de la fila
 c00009c:	1ccc      	adds	r4, r1, #3
    add r5, r2, #3                    @ r5 = Límite superior de la columna
 c00009e:	1cd5      	adds	r5, r2, #3

    bx lr
 c0000a0:	4770      	bx	lr

0c0000a2 <region_row_loop_t>:
    @ r5 = limite max region (columna)
    @ r6 = bit de desactivacion desplazado
    @ r7 = desplazamiento total (fila + columna)

region_row_loop_t:
    cmp r1, r4
 c0000a2:	42a1      	cmp	r1, r4
    bge end_of_region_t
 c0000a4:	da10      	bge.n	c0000c8 <end_of_region_t>

	push {r4}
 c0000a6:	b410      	push	{r4}

0c0000a8 <region_col_loop_t>:
region_col_loop_t:
	push {r5}						@ Backup del limite superior de la columna
 c0000a8:	b420      	push	{r5}
    cmp r2, r5
 c0000aa:	42aa      	cmp	r2, r5
    bge end_of_column_t
 c0000ac:	da08      	bge.n	c0000c0 <end_of_column_t>

    lsl r4, r1, #5                  @ Desplazamiento fila (r1 * 32)
 c0000ae:	014c      	lsls	r4, r1, #5
    lsl r5, r2, #1                  @ Desplazamiento columna (r2 * 2)
 c0000b0:	0055      	lsls	r5, r2, #1
    add r7, r4, r5                 	@ Desplazamiento total de la celda (fila + columna)
 c0000b2:	1967      	adds	r7, r4, r5

    ldrh r3, [r0, r7]
 c0000b4:	5bc3      	ldrh	r3, [r0, r7]
    bic r3, r3, r6                    @ celda &= ~(1 << displace)
 c0000b6:	43b3      	bics	r3, r6
    strh r3, [r0, r7]
 c0000b8:	53c3      	strh	r3, [r0, r7]

    add r2, r2, #1
 c0000ba:	3201      	adds	r2, #1
	pop {r5}
 c0000bc:	bc20      	pop	{r5}
    b region_col_loop_t
 c0000be:	e7f3      	b.n	c0000a8 <region_col_loop_t>

0c0000c0 <end_of_column_t>:

end_of_column_t:
    add r1, r1, #1
 c0000c0:	3101      	adds	r1, #1
    sub r2, r2, #3
 c0000c2:	3a03      	subs	r2, #3
    pop {r4}						@ Restaurar el limite superior de la fila
 c0000c4:	bc10      	pop	{r4}
    b region_row_loop_t
 c0000c6:	e7ec      	b.n	c0000a2 <region_row_loop_t>

0c0000c8 <end_of_region_t>:

end_of_region_t:
    bx lr
 c0000c8:	4770      	bx	lr
	...

0c0000cc <sudoku_candidatos_init_arm>:
    @ r4 = desplazamiento fila
    @ r5 = desplazamiento columna
    @ r6 = 0x1FF0 lista de candidatos
    @ r7 = desplazamiento total

	MOV r9, r1						@ r9 = version propagar (C=0, ARM=1, THUMB=2)
 c0000cc:	e1a09001 	mov	r9, r1

    MOV r1, #0
 c0000d0:	e3a01000 	mov	r1, #0
    MOV r6, #0x1F00               	@ Cargar parte alta de (0x1F00)
 c0000d4:	e3a06c1f 	mov	r6, #7936	; 0x1f00
    ORR r6, r6, #0x00F0           	@ Combinar parte baja (0x00F0) para obtener 0x1FF0
 c0000d8:	e38660f0 	orr	r6, r6, #240	; 0xf0

0c0000dc <init_fila>:

init_fila:
    CMP r1, #9
 c0000dc:	e3510009 	cmp	r1, #9
    BGE fin_init
 c0000e0:	aa00000f 	bge	c000124 <fin_init>

    LSL r4, r1, #5					@ Desplazamiento a siguiente fila (r1 * 32 bytes)
 c0000e4:	e1a04281 	lsl	r4, r1, #5

    MOV r2, #0
 c0000e8:	e3a02000 	mov	r2, #0

0c0000ec <init_columna>:
init_columna:
    CMP r2, #9
 c0000ec:	e3520009 	cmp	r2, #9
    BGE fin_init_columna
 c0000f0:	aa000009 	bge	c00011c <fin_init_columna>

    LSL r5, r2, #1					@ Desplazamiento a siguiente columna (r2 * 2 bytes)
 c0000f4:	e1a05082 	lsl	r5, r2, #1

    ADD r7, r4, r5        			@ Desplazamiento total (fila + columna)
 c0000f8:	e0847005 	add	r7, r4, r5

    LDRH r3, [r0, r7]
 c0000fc:	e19030b7 	ldrh	r3, [r0, r7]

   	AND r8, r3, #0x8000				@ Objeter valor de la pista
 c000100:	e2038902 	and	r8, r3, #32768	; 0x8000
	CMP r8, #0x8000					@ Si pista == 1 se omite la inicializacion de candidatos
 c000104:	e3580902 	cmp	r8, #32768	; 0x8000
    BGE skip_init
 c000108:	aa000001 	bge	c000114 <skip_init>

    ORR r3, r3, r6        			@ celda |= 0x1FF0 - Activar todos los candidatos
 c00010c:	e1833006 	orr	r3, r3, r6
    STRH r3, [r0, r7]
 c000110:	e18030b7 	strh	r3, [r0, r7]

0c000114 <skip_init>:

skip_init:
    ADD r2, r2, #1
 c000114:	e2822001 	add	r2, r2, #1
    B init_columna
 c000118:	eafffff3 	b	c0000ec <init_columna>

0c00011c <fin_init_columna>:

fin_init_columna:
    ADD r1, r1, #1
 c00011c:	e2811001 	add	r1, r1, #1
    B init_fila
 c000120:	eaffffed 	b	c0000dc <init_fila>

0c000124 <fin_init>:

fin_init:

@ Recorrer la cuadricula para llamar a las versiones de propagar

	MOV r10, #0							@ Contador de celdas vacias
 c000124:	e3a0a000 	mov	sl, #0
	MOV r1, #0
 c000128:	e3a01000 	mov	r1, #0

0c00012c <fila_cuadricula>:
fila_cuadricula:
	CMP r1, #9
 c00012c:	e3510009 	cmp	r1, #9
	BGE fin_cuadricula
 c000130:	aa00001b 	bge	c0001a4 <fin_cuadricula>

	LSL r4, r1, #5
 c000134:	e1a04281 	lsl	r4, r1, #5

	MOV r2, #0
 c000138:	e3a02000 	mov	r2, #0

0c00013c <recorrer_columna>:
recorrer_columna:
	CMP r2, #9
 c00013c:	e3520009 	cmp	r2, #9
	BGE siguiente_fila
 c000140:	aa000015 	bge	c00019c <siguiente_fila>

	LSL r6, r2, #1
 c000144:	e1a06082 	lsl	r6, r2, #1

	ADD r7, r4, r6
 c000148:	e0847006 	add	r7, r4, r6

	LDRH r3, [r0, r7]
 c00014c:	e19030b7 	ldrh	r3, [r0, r7]

	AND r3, r3, #0xF				@celda_leer_valor()
 c000150:	e203300f 	and	r3, r3, #15
	CMP r3, #0
 c000154:	e3530000 	cmp	r3, #0
	BEQ skip_propagation
 c000158:	0a000003 	beq	c00016c <skip_propagation>

	CMP r9, #0
 c00015c:	e3590000 	cmp	r9, #0
	BEQ propagar_C
 c000160:	0a000003 	beq	c000174 <propagar_C>

	CMP r9, #1
 c000164:	e3590001 	cmp	r9, #1
	BEQ propagar_ARM
 c000168:	0a000005 	beq	c000184 <propagar_ARM>

0c00016c <skip_propagation>:
skip_propagation:
	ADD r10, r10, #1
 c00016c:	e28aa001 	add	sl, sl, #1
	B final_columna
 c000170:	ea000007 	b	c000194 <final_columna>

0c000174 <propagar_C>:
propagar_C:
	STMED SP!, {r0-r12, r14}
 c000174:	e82d5fff 	stmda	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	BL sudoku_candidatos_propagar_c
 c000178:	eb00007e 	bl	c000378 <sudoku_candidatos_propagar_c>
	LDMED SP!, {r0-r12, r14}
 c00017c:	e9bd5fff 	ldmib	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	B final_columna
 c000180:	ea000003 	b	c000194 <final_columna>

0c000184 <propagar_ARM>:
propagar_ARM:
	STMED SP!, {r0-r12, r14}
 c000184:	e82d5fff 	stmda	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	BL sudoku_candidatos_propagar_arm
 c000188:	eb000007 	bl	c0001ac <sudoku_candidatos_propagar_arm>
	LDMED SP!, {r0-r12, r14}
 c00018c:	e9bd5fff 	ldmib	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr}
	B final_columna
 c000190:	eaffffff 	b	c000194 <final_columna>

0c000194 <final_columna>:
#propagar_THUMB:
#	BL sudoku_candidatos_propagar_arm
#	B final_columna
final_columna:
	ADD r2, r2, #1
 c000194:	e2822001 	add	r2, r2, #1
	B recorrer_columna
 c000198:	eaffffe7 	b	c00013c <recorrer_columna>

0c00019c <siguiente_fila>:
siguiente_fila:
	ADD r1, r1, #1
 c00019c:	e2811001 	add	r1, r1, #1
	B fila_cuadricula
 c0001a0:	eaffffe1 	b	c00012c <fila_cuadricula>

0c0001a4 <fin_cuadricula>:
fin_cuadricula:
	MOV r0, r10
 c0001a4:	e1a0000a 	mov	r0, sl
  	BX lr
 c0001a8:	e12fff1e 	bx	lr

0c0001ac <sudoku_candidatos_propagar_arm>:


@ Calcula el desplazamiento necesario para llegar a la celda, y llama a las funciones de propagacion (fila, columna y region)
sudoku_candidatos_propagar_arm:
	STMFD sp!, {r11, r12, lr}
 c0001ac:	e92d5800 	push	{fp, ip, lr}
	@ r4 = desplazamiento de la fila
	@ r5 = desplazamiento de la columna
	@ r6 = bit desplazado (se usara para desactivar los candidatos)
	@ r7 = desplazamiento total (r4 + r5)

	LSL r4, r1, #5							@ Desplazamiento fila (r1 * 32 bytes)
 c0001b0:	e1a04281 	lsl	r4, r1, #5

	LSL r5, r2, #1							@ Desplazamiento columna (r2 * 2 bytes)
 c0001b4:	e1a05082 	lsl	r5, r2, #1

	ADD r7, r4, r5							@ Desplazamiento total (fila + columna)
 c0001b8:	e0847005 	add	r7, r4, r5

	ADD r8, r3, #3							@ r8 = displace = (3 + r3)
 c0001bc:	e2838003 	add	r8, r3, #3

	MOV r6, #1
 c0001c0:	e3a06001 	mov	r6, #1
	LSL r6, r6, r8							@ desplazar bit a la izquierda r8 posiciones
 c0001c4:	e1a06816 	lsl	r6, r6, r8

	LDRH r8, [r0, r7]
 c0001c8:	e19080b7 	ldrh	r8, [r0, r7]

@ Actualiza los candidatos de la fila (verticalmente)
	MOV r9, #0
 c0001cc:	e3a09000 	mov	r9, #0

0c0001d0 <fila_loop>:
fila_loop:
    CMP r9, #9
 c0001d0:	e3590009 	cmp	r9, #9
    BGE fin_fila
 c0001d4:	aa00000b 	bge	c000208 <fin_fila>

    LSL r10, r9, #5               			@ Desplazar la fila (r9 * 32)
 c0001d8:	e1a0a289 	lsl	sl, r9, #5
    ADD r11, r10, r5               			@ r11 = desplazamiento total = fila + columna (columna fija para r5)
 c0001dc:	e08ab005 	add	fp, sl, r5

    LDRH r8, [r0, r11]
 c0001e0:	e19080bb 	ldrh	r8, [r0, fp]

    AND r12, r8, #0x8000
 c0001e4:	e208c902 	and	ip, r8, #32768	; 0x8000
    CMP r12, #0x8000
 c0001e8:	e35c0902 	cmp	ip, #32768	; 0x8000
    BEQ skip_row
 c0001ec:	0a000003 	beq	c000200 <skip_row>

    CMP r9, r1
 c0001f0:	e1590001 	cmp	r9, r1
    BEQ skip_row
 c0001f4:	0a000001 	beq	c000200 <skip_row>

    BIC r8, r8, r6               			@ celda &= ~(1 << displace) - Actualizar el bit candidato
 c0001f8:	e1c88006 	bic	r8, r8, r6
    STRH r8, [r0, r11]
 c0001fc:	e18080bb 	strh	r8, [r0, fp]

0c000200 <skip_row>:
skip_row:
    ADD r9, r9, #1
 c000200:	e2899001 	add	r9, r9, #1
    B fila_loop
 c000204:	eafffff1 	b	c0001d0 <fila_loop>

0c000208 <fin_fila>:
fin_fila:
@ Actualiza los candidatos de la columna (Horizontalmente)
	MOV r9, #0
 c000208:	e3a09000 	mov	r9, #0

0c00020c <col_loop>:
col_loop:
    CMP r9, #9
 c00020c:	e3590009 	cmp	r9, #9
    BGE fin_col
 c000210:	aa00000b 	bge	c000244 <fin_col>

    LSL r10, r9, #1               			@ Desplazar la columna (r9 * 2)
 c000214:	e1a0a089 	lsl	sl, r9, #1
    ADD r11, r4, r10               			@ r11 = desplazamiento total = fila + columna (fila fija para r4)
 c000218:	e084b00a 	add	fp, r4, sl

    LDRH r8, [r0, r11]
 c00021c:	e19080bb 	ldrh	r8, [r0, fp]

    AND r12, r8, #0x8000
 c000220:	e208c902 	and	ip, r8, #32768	; 0x8000
    CMP r12, #0x8000
 c000224:	e35c0902 	cmp	ip, #32768	; 0x8000
    BEQ skip_column
 c000228:	0a000003 	beq	c00023c <skip_column>

    CMP r9, r2
 c00022c:	e1590002 	cmp	r9, r2
    BEQ skip_column
 c000230:	0a000001 	beq	c00023c <skip_column>

    BIC r8, r8, r6               			@ celda &= ~(1 << displace) - Actualizar bit candidato
 c000234:	e1c88006 	bic	r8, r8, r6
    STRH r8, [r0, r11]
 c000238:	e18080bb 	strh	r8, [r0, fp]

0c00023c <skip_column>:
skip_column:
    ADD r9, r9, #1
 c00023c:	e2899001 	add	r9, r9, #1
    B col_loop
 c000240:	eafffff1 	b	c00020c <col_loop>

0c000244 <fin_col>:
fin_col:
@ Calcula el limite inferior (esquina superior izquierda) y limite superior de la region 3x3 correspondiente a la celda
	MOV r8, r1
 c000244:	e1a08001 	mov	r8, r1
	MOV r9, #0
 c000248:	e3a09000 	mov	r9, #0

0c00024c <row_index>:
row_index:
	CMP r8, #3
 c00024c:	e3580003 	cmp	r8, #3
	BLT row_index_end						@ Si es menor a 3, termina el calculo de fila
 c000250:	ba000002 	blt	c000260 <row_index_end>

	SUB r8, r8, #3							@ Restas sucesivas para determinar la region de la celda (1°,2° o 3° region vertical)
 c000254:	e2488003 	sub	r8, r8, #3
	ADD r9, r9, #3							@ Aumentar #3 para ubicarse al inicio de la region correspondiente
 c000258:	e2899003 	add	r9, r9, #3
	B row_index
 c00025c:	eafffffa 	b	c00024c <row_index>

0c000260 <row_index_end>:
row_index_end:
	MOV r7, r9								@ Guardar el indice calculado en r8 (fila)
 c000260:	e1a07009 	mov	r7, r9

	MOV r8, r2
 c000264:	e1a08002 	mov	r8, r2
	MOV r9, #0
 c000268:	e3a09000 	mov	r9, #0

0c00026c <col_index>:
col_index:
	CMP r8, #3
 c00026c:	e3580003 	cmp	r8, #3
	BLT col_index_end						@ Si es menor a 3, termina el calculo de columna
 c000270:	ba000002 	blt	c000280 <col_index_end>

	SUB r8, r8, #3							@ Restas sucesivas para determinar la region de la celda (1°,2° o 3° region horizontal)
 c000274:	e2488003 	sub	r8, r8, #3
	ADD r9, r9, #3							@ Aumentar #3 para ubicarse al inicio de la region correspondiente
 c000278:	e2899003 	add	r9, r9, #3
	B col_index
 c00027c:	eafffffa 	b	c00026c <col_index>

0c000280 <col_index_end>:
col_index_end:
	MOV r8, r9								@ Guardar el indice calculado en r7 (columna)
 c000280:	e1a08009 	mov	r8, r9

	ADD r9, r7, #3							@ r9 = Limite superior de la fila
 c000284:	e2879003 	add	r9, r7, #3
	ADD r10, r8, #3							@ r10 = Limite superior de la columna
 c000288:	e288a003 	add	sl, r8, #3

0c00028c <region_row_loop>:
@ Actualiza los candidatos de la region 3x3
region_row_loop:
	CMP r7, r9
 c00028c:	e1570009 	cmp	r7, r9
	BGE end_of_region
 c000290:	aa000013 	bge	c0002e4 <end_of_region>

0c000294 <region_col_loop>:
region_col_loop:
	CMP r8, r10
 c000294:	e158000a 	cmp	r8, sl
	BGE end_of_column
 c000298:	aa00000e 	bge	c0002d8 <end_of_column>

	LSL r4, r7, #5							@ Desplazamiento fila (r7 * 32)
 c00029c:	e1a04287 	lsl	r4, r7, #5
	LSL r5, r8, #1							@ Desplazamiento columna (r10 * 2)
 c0002a0:	e1a05088 	lsl	r5, r8, #1
	ADD r11, r4, r5							@ Desplazamiento total de la celda (fila + columna)
 c0002a4:	e084b005 	add	fp, r4, r5

	LDRH r12, [r0, r11]
 c0002a8:	e190c0bb 	ldrh	ip, [r0, fp]

	AND r4, r12, #0x8000
 c0002ac:	e20c4902 	and	r4, ip, #32768	; 0x8000
	CMP r4, #0x8000
 c0002b0:	e3540902 	cmp	r4, #32768	; 0x8000
	BEQ skip_cell
 c0002b4:	0a000005 	beq	c0002d0 <skip_cell>

	CMP r7, r1
 c0002b8:	e1570001 	cmp	r7, r1
	BEQ skip_cell
 c0002bc:	0a000003 	beq	c0002d0 <skip_cell>

	CMP r8, r2
 c0002c0:	e1580002 	cmp	r8, r2
	BEQ skip_cell
 c0002c4:	0a000001 	beq	c0002d0 <skip_cell>

	BIC r12, r12, r6						@ celda &= ~(1 << displace) - Actualizar bit candidato
 c0002c8:	e1ccc006 	bic	ip, ip, r6
	STRH r12, [r0, r11]
 c0002cc:	e180c0bb 	strh	ip, [r0, fp]

0c0002d0 <skip_cell>:
skip_cell:
	ADD r8, r8, #1
 c0002d0:	e2888001 	add	r8, r8, #1
	B region_col_loop
 c0002d4:	eaffffee 	b	c000294 <region_col_loop>

0c0002d8 <end_of_column>:
end_of_column:
	ADD r7, r7, #1
 c0002d8:	e2877001 	add	r7, r7, #1
	SUB r8, r8, #3						@ Regresar a la primera columa de la región
 c0002dc:	e2488003 	sub	r8, r8, #3
	B region_row_loop
 c0002e0:	eaffffe9 	b	c00028c <region_row_loop>

0c0002e4 <end_of_region>:
end_of_region:
	LDMFD sp!, {r11, r12, lr}
 c0002e4:	e8bd5800 	pop	{fp, ip, lr}
	BX lr
 c0002e8:	e12fff1e 	bx	lr

0c0002ec <start>:
start:
.arm    /* indicates that we are using the ARM instruction set */

#------standard initial code
# --- Setup interrupt / exception vectors
      B       Reset_Handler
 c0002ec:	eaffffff 	b	c0002f0 <Reset_Handler>

0c0002f0 <Reset_Handler>:
# Reset Handler:
# the processor starts executing this code after system reset
################################################################################
Reset_Handler:
#
        MOV     sp, #0x4000      /*  set up stack pointer (r13) */
 c0002f0:	e3a0d901 	mov	sp, #16384	; 0x4000
# If there are 4 or less parameters when calling a C function the compiler
# assumes that they have been stored in r0-r3.
# If there are more parameters you have to store them in the data stack
# using the stack pointer
# function __c_copy is in copy.c
        LDR     r0, =cuadricula  /*  puntero a la @ inicial de la cuadricula */
 c0002f4:	e59f000c 	ldr	r0, [pc, #12]	; c000308 <stop+0x4>

.extern     sudoku9x9
        ldr         r5, = sudoku9x9
 c0002f8:	e59f500c 	ldr	r5, [pc, #12]	; c00030c <stop+0x8>
        mov         lr, pc
 c0002fc:	e1a0e00f 	mov	lr, pc
        bx          r5
 c000300:	e12fff15 	bx	r5

0c000304 <stop>:

.extern		sudoku_candidatos_propagar_c
stop:
        B       stop        /*  end of program */
 c000304:	eafffffe 	b	c000304 <stop>
 c000308:	0c000ca0 	.word	0x0c000ca0
 c00030c:	0c000c14 	.word	0x0c000c14

0c000310 <celda_leer_valor>:
}

/* extrae el valor almacenado en los 16 bits de la celda */
static inline uint8_t
celda_leer_valor(CELDA celda)
{
 c000310:	e1a0c00d 	mov	ip, sp
 c000314:	e92dd800 	push	{fp, ip, lr, pc}
 c000318:	e24cb004 	sub	fp, ip, #4
 c00031c:	e24dd008 	sub	sp, sp, #8
 c000320:	e1a03000 	mov	r3, r0
 c000324:	e14b30be 	strh	r3, [fp, #-14]
    return (celda & 0x000F);
 c000328:	e15b30be 	ldrh	r3, [fp, #-14]
 c00032c:	e20330ff 	and	r3, r3, #255	; 0xff
 c000330:	e203300f 	and	r3, r3, #15
 c000334:	e20330ff 	and	r3, r3, #255	; 0xff
}
 c000338:	e1a00003 	mov	r0, r3
 c00033c:	e24bd00c 	sub	sp, fp, #12
 c000340:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000344:	e12fff1e 	bx	lr

0c000348 <activar_error>:

/* Activa el bit de error en la celda indicada */
static inline void
activar_error(CELDA celda)
{
 c000348:	e1a0c00d 	mov	ip, sp
 c00034c:	e92dd800 	push	{fp, ip, lr, pc}
 c000350:	e24cb004 	sub	fp, ip, #4
 c000354:	e24dd008 	sub	sp, sp, #8
 c000358:	e1a03000 	mov	r3, r0
 c00035c:	e14b30be 	strh	r3, [fp, #-14]
	celda = celda |= 0x4000;
 c000360:	e15b30be 	ldrh	r3, [fp, #-14]
 c000364:	e3833901 	orr	r3, r3, #16384	; 0x4000
 c000368:	e14b30be 	strh	r3, [fp, #-14]
}
 c00036c:	e24bd00c 	sub	sp, fp, #12
 c000370:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000374:	e12fff1e 	bx	lr

0c000378 <sudoku_candidatos_propagar_c>:

/* Propaga el valor de una determinada celda para actualizar las listas de candidatos en su fila, columna y region */
void
sudoku_candidatos_propagar_c(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int fila, int columna, uint8_t valor)
{
 c000378:	e1a0c00d 	mov	ip, sp
 c00037c:	e92dd800 	push	{fp, ip, lr, pc}
 c000380:	e24cb004 	sub	fp, ip, #4
 c000384:	e24dd030 	sub	sp, sp, #48	; 0x30
 c000388:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
 c00038c:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
 c000390:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
 c000394:	e54b3039 	strb	r3, [fp, #-57]	; 0xffffffc7

	int displace = 3 + (int)valor;
 c000398:	e55b3039 	ldrb	r3, [fp, #-57]	; 0xffffffc7
 c00039c:	e2833003 	add	r3, r3, #3
 c0003a0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

	/* recorrer cada fila desactivando el candidato de la lista */
	    int row = 0;
 c0003a4:	e3a03000 	mov	r3, #0
 c0003a8:	e50b3010 	str	r3, [fp, #-16]
	    while(row < NUM_FILAS){
 c0003ac:	ea00002a 	b	c00045c <sudoku_candidatos_propagar_c+0xe4>
	    	uint16_t celda = cuadricula[row][columna];
 c0003b0:	e51b3010 	ldr	r3, [fp, #-16]
 c0003b4:	e1a03283 	lsl	r3, r3, #5
 c0003b8:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
 c0003bc:	e0822003 	add	r2, r2, r3
 c0003c0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
 c0003c4:	e1a03083 	lsl	r3, r3, #1
 c0003c8:	e0823003 	add	r3, r2, r3
 c0003cc:	e1d330b0 	ldrh	r3, [r3]
 c0003d0:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
	    	if(((celda & 0x8000) != 0x8000) || row != fila){
 c0003d4:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
 c0003d8:	e1a03803 	lsl	r3, r3, #16
 c0003dc:	e1a03843 	asr	r3, r3, #16
 c0003e0:	e3530000 	cmp	r3, #0
 c0003e4:	aa000003 	bge	c0003f8 <sudoku_candidatos_propagar_c+0x80>
 c0003e8:	e51b2010 	ldr	r2, [fp, #-16]
 c0003ec:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
 c0003f0:	e1520003 	cmp	r2, r3
 c0003f4:	0a000015 	beq	c000450 <sudoku_candidatos_propagar_c+0xd8>
	    		celda &= ~(1 << displace);
 c0003f8:	e3a02001 	mov	r2, #1
 c0003fc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c000400:	e1a03312 	lsl	r3, r2, r3
 c000404:	e1a03803 	lsl	r3, r3, #16
 c000408:	e1a03823 	lsr	r3, r3, #16
 c00040c:	e1e03003 	mvn	r3, r3
 c000410:	e1a03803 	lsl	r3, r3, #16
 c000414:	e1a02823 	lsr	r2, r3, #16
 c000418:	e15b31be 	ldrh	r3, [fp, #-30]	; 0xffffffe2
 c00041c:	e0023003 	and	r3, r2, r3
 c000420:	e1a03803 	lsl	r3, r3, #16
 c000424:	e1a03823 	lsr	r3, r3, #16
 c000428:	e14b31be 	strh	r3, [fp, #-30]	; 0xffffffe2
	    		cuadricula[row][columna] = celda;
 c00042c:	e51b3010 	ldr	r3, [fp, #-16]
 c000430:	e1a03283 	lsl	r3, r3, #5
 c000434:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
 c000438:	e0822003 	add	r2, r2, r3
 c00043c:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
 c000440:	e1a03083 	lsl	r3, r3, #1
 c000444:	e0823003 	add	r3, r2, r3
 c000448:	e15b21be 	ldrh	r2, [fp, #-30]	; 0xffffffe2
 c00044c:	e1c320b0 	strh	r2, [r3]
	    	}
	    	row++;
 c000450:	e51b3010 	ldr	r3, [fp, #-16]
 c000454:	e2833001 	add	r3, r3, #1
 c000458:	e50b3010 	str	r3, [fp, #-16]

	int displace = 3 + (int)valor;

	/* recorrer cada fila desactivando el candidato de la lista */
	    int row = 0;
	    while(row < NUM_FILAS){
 c00045c:	e51b3010 	ldr	r3, [fp, #-16]
 c000460:	e3530008 	cmp	r3, #8
 c000464:	daffffd1 	ble	c0003b0 <sudoku_candidatos_propagar_c+0x38>
	    	}
	    	row++;
	    }

    /* recorrer cada columna desactivando el candidato de la lista */
	int col = 0;
 c000468:	e3a03000 	mov	r3, #0
 c00046c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	while(col < NUM_COLUMNAS - 7){
 c000470:	ea00002a 	b	c000520 <sudoku_candidatos_propagar_c+0x1a8>
	    uint16_t celda = cuadricula[fila][col];
 c000474:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
 c000478:	e1a03283 	lsl	r3, r3, #5
 c00047c:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
 c000480:	e0822003 	add	r2, r2, r3
 c000484:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000488:	e1a03083 	lsl	r3, r3, #1
 c00048c:	e0823003 	add	r3, r2, r3
 c000490:	e1d330b0 	ldrh	r3, [r3]
 c000494:	e14b32b0 	strh	r3, [fp, #-32]	; 0xffffffe0
	    if(((celda & 0x8000) != 0x8000) || col != columna){
 c000498:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
 c00049c:	e1a03803 	lsl	r3, r3, #16
 c0004a0:	e1a03843 	asr	r3, r3, #16
 c0004a4:	e3530000 	cmp	r3, #0
 c0004a8:	aa000003 	bge	c0004bc <sudoku_candidatos_propagar_c+0x144>
 c0004ac:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c0004b0:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
 c0004b4:	e1520003 	cmp	r2, r3
 c0004b8:	0a000015 	beq	c000514 <sudoku_candidatos_propagar_c+0x19c>
	        celda &= ~(1 << displace);  // Desactivar el candidato de la lista con una operación NAND
 c0004bc:	e3a02001 	mov	r2, #1
 c0004c0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c0004c4:	e1a03312 	lsl	r3, r2, r3
 c0004c8:	e1a03803 	lsl	r3, r3, #16
 c0004cc:	e1a03823 	lsr	r3, r3, #16
 c0004d0:	e1e03003 	mvn	r3, r3
 c0004d4:	e1a03803 	lsl	r3, r3, #16
 c0004d8:	e1a02823 	lsr	r2, r3, #16
 c0004dc:	e15b32b0 	ldrh	r3, [fp, #-32]	; 0xffffffe0
 c0004e0:	e0023003 	and	r3, r2, r3
 c0004e4:	e1a03803 	lsl	r3, r3, #16
 c0004e8:	e1a03823 	lsr	r3, r3, #16
 c0004ec:	e14b32b0 	strh	r3, [fp, #-32]	; 0xffffffe0
	        cuadricula[fila][col] = celda;
 c0004f0:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
 c0004f4:	e1a03283 	lsl	r3, r3, #5
 c0004f8:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
 c0004fc:	e0822003 	add	r2, r2, r3
 c000500:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000504:	e1a03083 	lsl	r3, r3, #1
 c000508:	e0823003 	add	r3, r2, r3
 c00050c:	e15b22b0 	ldrh	r2, [fp, #-32]	; 0xffffffe0
 c000510:	e1c320b0 	strh	r2, [r3]
	    }
	    col++;
 c000514:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000518:	e2833001 	add	r3, r3, #1
 c00051c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	    	row++;
	    }

    /* recorrer cada columna desactivando el candidato de la lista */
	int col = 0;
	while(col < NUM_COLUMNAS - 7){
 c000520:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000524:	e3530008 	cmp	r3, #8
 c000528:	daffffd1 	ble	c000474 <sudoku_candidatos_propagar_c+0xfc>
	    }
	    col++;
	}

    /* Calcular la posicion inicial para cada region 3x3 correspondiente */
    int row_start = (fila / 3) * 3;
 c00052c:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
 c000530:	e59f2150 	ldr	r2, [pc, #336]	; c000688 <sudoku_candidatos_propagar_c+0x310>
 c000534:	e0c21293 	smull	r1, r2, r3, r2
 c000538:	e1a03fc3 	asr	r3, r3, #31
 c00053c:	e0632002 	rsb	r2, r3, r2
 c000540:	e1a03002 	mov	r3, r2
 c000544:	e1a03083 	lsl	r3, r3, #1
 c000548:	e0833002 	add	r3, r3, r2
 c00054c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    int col_start = (columna / 3) * 3;
 c000550:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
 c000554:	e59f212c 	ldr	r2, [pc, #300]	; c000688 <sudoku_candidatos_propagar_c+0x310>
 c000558:	e0c21293 	smull	r1, r2, r3, r2
 c00055c:	e1a03fc3 	asr	r3, r3, #31
 c000560:	e0632002 	rsb	r2, r3, r2
 c000564:	e1a03002 	mov	r3, r2
 c000568:	e1a03083 	lsl	r3, r3, #1
 c00056c:	e0833002 	add	r3, r3, r2
 c000570:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8

    /* Recorrer la region desactivando el candidato de la lista */
    row = row_start;
 c000574:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c000578:	e50b3010 	str	r3, [fp, #-16]
    while(row < (row_start + 3)){
 c00057c:	ea000039 	b	c000668 <sudoku_candidatos_propagar_c+0x2f0>
    	int col = col_start;
 c000580:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c000584:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    	while(col < (col_start + 3)){
 c000588:	ea00002e 	b	c000648 <sudoku_candidatos_propagar_c+0x2d0>
    		uint16_t celda = cuadricula[row][col];
 c00058c:	e51b3010 	ldr	r3, [fp, #-16]
 c000590:	e1a03283 	lsl	r3, r3, #5
 c000594:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
 c000598:	e0822003 	add	r2, r2, r3
 c00059c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c0005a0:	e1a03083 	lsl	r3, r3, #1
 c0005a4:	e0823003 	add	r3, r2, r3
 c0005a8:	e1d330b0 	ldrh	r3, [r3]
 c0005ac:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
    		if(((celda & 0x8000) != 0x8000) || row != fila || col != columna){
 c0005b0:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c0005b4:	e1a03803 	lsl	r3, r3, #16
 c0005b8:	e1a03843 	asr	r3, r3, #16
 c0005bc:	e3530000 	cmp	r3, #0
 c0005c0:	aa000007 	bge	c0005e4 <sudoku_candidatos_propagar_c+0x26c>
 c0005c4:	e51b2010 	ldr	r2, [fp, #-16]
 c0005c8:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
 c0005cc:	e1520003 	cmp	r2, r3
 c0005d0:	1a000003 	bne	c0005e4 <sudoku_candidatos_propagar_c+0x26c>
 c0005d4:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
 c0005d8:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
 c0005dc:	e1520003 	cmp	r2, r3
 c0005e0:	0a000015 	beq	c00063c <sudoku_candidatos_propagar_c+0x2c4>
    			celda &= ~(1 << displace);
 c0005e4:	e3a02001 	mov	r2, #1
 c0005e8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c0005ec:	e1a03312 	lsl	r3, r2, r3
 c0005f0:	e1a03803 	lsl	r3, r3, #16
 c0005f4:	e1a03823 	lsr	r3, r3, #16
 c0005f8:	e1e03003 	mvn	r3, r3
 c0005fc:	e1a03803 	lsl	r3, r3, #16
 c000600:	e1a02823 	lsr	r2, r3, #16
 c000604:	e15b32ba 	ldrh	r3, [fp, #-42]	; 0xffffffd6
 c000608:	e0023003 	and	r3, r2, r3
 c00060c:	e1a03803 	lsl	r3, r3, #16
 c000610:	e1a03823 	lsr	r3, r3, #16
 c000614:	e14b32ba 	strh	r3, [fp, #-42]	; 0xffffffd6
    			cuadricula[row][col] = celda;
 c000618:	e51b3010 	ldr	r3, [fp, #-16]
 c00061c:	e1a03283 	lsl	r3, r3, #5
 c000620:	e51b2030 	ldr	r2, [fp, #-48]	; 0xffffffd0
 c000624:	e0822003 	add	r2, r2, r3
 c000628:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c00062c:	e1a03083 	lsl	r3, r3, #1
 c000630:	e0823003 	add	r3, r2, r3
 c000634:	e15b22ba 	ldrh	r2, [fp, #-42]	; 0xffffffd6
 c000638:	e1c320b0 	strh	r2, [r3]
    		}
   			col++;
 c00063c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000640:	e2833001 	add	r3, r3, #1
 c000644:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    /* Recorrer la region desactivando el candidato de la lista */
    row = row_start;
    while(row < (row_start + 3)){
    	int col = col_start;
    	while(col < (col_start + 3)){
 c000648:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c00064c:	e2832003 	add	r2, r3, #3
 c000650:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000654:	e1520003 	cmp	r2, r3
 c000658:	caffffcb 	bgt	c00058c <sudoku_candidatos_propagar_c+0x214>
    			celda &= ~(1 << displace);
    			cuadricula[row][col] = celda;
    		}
   			col++;
    	}
    	row++;
 c00065c:	e51b3010 	ldr	r3, [fp, #-16]
 c000660:	e2833001 	add	r3, r3, #1
 c000664:	e50b3010 	str	r3, [fp, #-16]
    int row_start = (fila / 3) * 3;
    int col_start = (columna / 3) * 3;

    /* Recorrer la region desactivando el candidato de la lista */
    row = row_start;
    while(row < (row_start + 3)){
 c000668:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
 c00066c:	e2832003 	add	r2, r3, #3
 c000670:	e51b3010 	ldr	r3, [fp, #-16]
 c000674:	e1520003 	cmp	r2, r3
 c000678:	caffffc0 	bgt	c000580 <sudoku_candidatos_propagar_c+0x208>
    		}
   			col++;
    	}
    	row++;
    }
}
 c00067c:	e24bd00c 	sub	sp, fp, #12
 c000680:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000684:	e12fff1e 	bx	lr
 c000688:	55555556 	.word	0x55555556

0c00068c <sudoku_candidatos_init_c>:
 * calcula todas las listas de candidatos (9x9)
 * necesario tras borrar o cambiar un valor (listas corrompidas)
 * retorna el numero de celdas vacias */
static int
sudoku_candidatos_init_c(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int version_propagar)
{
 c00068c:	e1a0c00d 	mov	ip, sp
 c000690:	e92dd800 	push	{fp, ip, lr, pc}
 c000694:	e24cb004 	sub	fp, ip, #4
 c000698:	e24dd020 	sub	sp, sp, #32
 c00069c:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
 c0006a0:	e50b102c 	str	r1, [fp, #-44]	; 0xffffffd4
 	/* Recorrer la cuadricula celda a celda inicializando la lista de candidatos */
 	int row=0;
 c0006a4:	e3a03000 	mov	r3, #0
 c0006a8:	e50b3010 	str	r3, [fp, #-16]
 		while(row < NUM_FILAS){
 c0006ac:	ea00002c 	b	c000764 <sudoku_candidatos_init_c+0xd8>
 			int col=0;
 c0006b0:	e3a03000 	mov	r3, #0
 c0006b4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
 			while(col < NUM_COLUMNAS - 7){
 c0006b8:	ea000023 	b	c00074c <sudoku_candidatos_init_c+0xc0>
 				int pista = cuadricula[row][col] & 0x8000;
 c0006bc:	e51b3010 	ldr	r3, [fp, #-16]
 c0006c0:	e1a03283 	lsl	r3, r3, #5
 c0006c4:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c0006c8:	e0822003 	add	r2, r2, r3
 c0006cc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0006d0:	e1a03083 	lsl	r3, r3, #1
 c0006d4:	e0823003 	add	r3, r2, r3
 c0006d8:	e1d330b0 	ldrh	r3, [r3]
 c0006dc:	e2033902 	and	r3, r3, #32768	; 0x8000
 c0006e0:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
 				if(pista == 0){
 c0006e4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c0006e8:	e3530000 	cmp	r3, #0
 c0006ec:	1a000013 	bne	c000740 <sudoku_candidatos_init_c+0xb4>
 					cuadricula[row][col] |= 0x1FF0;
 c0006f0:	e51b3010 	ldr	r3, [fp, #-16]
 c0006f4:	e1a03283 	lsl	r3, r3, #5
 c0006f8:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c0006fc:	e0821003 	add	r1, r2, r3
 c000700:	e51b3010 	ldr	r3, [fp, #-16]
 c000704:	e1a03283 	lsl	r3, r3, #5
 c000708:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c00070c:	e0822003 	add	r2, r2, r3
 c000710:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000714:	e1a03083 	lsl	r3, r3, #1
 c000718:	e0823003 	add	r3, r2, r3
 c00071c:	e1d330b0 	ldrh	r3, [r3]
 c000720:	e3833d7f 	orr	r3, r3, #8128	; 0x1fc0
 c000724:	e3833030 	orr	r3, r3, #48	; 0x30
 c000728:	e1a03803 	lsl	r3, r3, #16
 c00072c:	e1a02823 	lsr	r2, r3, #16
 c000730:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000734:	e1a03083 	lsl	r3, r3, #1
 c000738:	e0813003 	add	r3, r1, r3
 c00073c:	e1c320b0 	strh	r2, [r3]
 				}
 				col++;
 c000740:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000744:	e2833001 	add	r3, r3, #1
 c000748:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
{
 	/* Recorrer la cuadricula celda a celda inicializando la lista de candidatos */
 	int row=0;
 		while(row < NUM_FILAS){
 			int col=0;
 			while(col < NUM_COLUMNAS - 7){
 c00074c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000750:	e3530008 	cmp	r3, #8
 c000754:	daffffd8 	ble	c0006bc <sudoku_candidatos_init_c+0x30>
 				if(pista == 0){
 					cuadricula[row][col] |= 0x1FF0;
 				}
 				col++;
 			}
 			row++;
 c000758:	e51b3010 	ldr	r3, [fp, #-16]
 c00075c:	e2833001 	add	r3, r3, #1
 c000760:	e50b3010 	str	r3, [fp, #-16]
static int
sudoku_candidatos_init_c(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], int version_propagar)
{
 	/* Recorrer la cuadricula celda a celda inicializando la lista de candidatos */
 	int row=0;
 		while(row < NUM_FILAS){
 c000764:	e51b3010 	ldr	r3, [fp, #-16]
 c000768:	e3530008 	cmp	r3, #8
 c00076c:	daffffcf 	ble	c0006b0 <sudoku_candidatos_init_c+0x24>

 	/* Recorer la cuadricula celda a celda:
 	 * Si la celda tiene valor => sudoku_candidatos_propagar_c
 	 * Si no tiene valor => actualizar contador de celdas vacías
 	 */
 	int celdas_vacias = 0;
 c000770:	e3a03000 	mov	r3, #0
 c000774:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 	row = 0;
 c000778:	e3a03000 	mov	r3, #0
 c00077c:	e50b3010 	str	r3, [fp, #-16]
 	while(row < NUM_FILAS){
 c000780:	ea00003a 	b	c000870 <sudoku_candidatos_init_c+0x1e4>
 		int col=0;
 c000784:	e3a03000 	mov	r3, #0
 c000788:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
 		while(col < NUM_COLUMNAS - 7){
 c00078c:	ea000031 	b	c000858 <sudoku_candidatos_init_c+0x1cc>
 			uint8_t valor_actual = celda_leer_valor(cuadricula[row][col]);
 c000790:	e51b3010 	ldr	r3, [fp, #-16]
 c000794:	e1a03283 	lsl	r3, r3, #5
 c000798:	e51b2028 	ldr	r2, [fp, #-40]	; 0xffffffd8
 c00079c:	e0822003 	add	r2, r2, r3
 c0007a0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c0007a4:	e1a03083 	lsl	r3, r3, #1
 c0007a8:	e0823003 	add	r3, r2, r3
 c0007ac:	e1d330b0 	ldrh	r3, [r3]
 c0007b0:	e1a00003 	mov	r0, r3
 c0007b4:	ebfffed5 	bl	c000310 <celda_leer_valor>
 c0007b8:	e1a03000 	mov	r3, r0
 c0007bc:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
 			if(valor_actual == 0x0000){
 c0007c0:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c0007c4:	e3530000 	cmp	r3, #0
 c0007c8:	1a000003 	bne	c0007dc <sudoku_candidatos_init_c+0x150>
 				celdas_vacias++;
 c0007cc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c0007d0:	e2833001 	add	r3, r3, #1
 c0007d4:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
 c0007d8:	ea00001b 	b	c00084c <sudoku_candidatos_init_c+0x1c0>
 			} else {
 				if(version_propagar == 0){
 c0007dc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c0007e0:	e3530000 	cmp	r3, #0
 c0007e4:	1a000004 	bne	c0007fc <sudoku_candidatos_init_c+0x170>
 					sudoku_candidatos_propagar_c(cuadricula, row, col, valor_actual);
 c0007e8:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c0007ec:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c0007f0:	e51b1010 	ldr	r1, [fp, #-16]
 c0007f4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
 c0007f8:	ebfffede 	bl	c000378 <sudoku_candidatos_propagar_c>
 				}
 				if(version_propagar == 1){
 c0007fc:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c000800:	e3530001 	cmp	r3, #1
 c000804:	1a000006 	bne	c000824 <sudoku_candidatos_init_c+0x198>
 					sudoku_candidatos_propagar_arm(cuadricula, row, col, valor_actual);
 c000808:	e51b3010 	ldr	r3, [fp, #-16]
 c00080c:	e20310ff 	and	r1, r3, #255	; 0xff
 c000810:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c000814:	e20320ff 	and	r2, r3, #255	; 0xff
 c000818:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c00081c:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c000820:	ebfffe61 	bl	c0001ac <sudoku_candidatos_propagar_arm>
 				}
 				if(version_propagar == 2){
 c000824:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c000828:	e3530002 	cmp	r3, #2
 c00082c:	1a000006 	bne	c00084c <sudoku_candidatos_init_c+0x1c0>
 					sudoku_candidatos_propagar_thumb(cuadricula, row, col, valor_actual);
 c000830:	e51b3010 	ldr	r3, [fp, #-16]
 c000834:	e20310ff 	and	r1, r3, #255	; 0xff
 c000838:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c00083c:	e20320ff 	and	r2, r3, #255	; 0xff
 c000840:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c000844:	e51b0028 	ldr	r0, [fp, #-40]	; 0xffffffd8
 c000848:	ebfffdec 	bl	c000000 <sudoku_candidatos_propagar_thumb>
 				}
 			}
 			col++;
 c00084c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c000850:	e2833001 	add	r3, r3, #1
 c000854:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
 	 */
 	int celdas_vacias = 0;
 	row = 0;
 	while(row < NUM_FILAS){
 		int col=0;
 		while(col < NUM_COLUMNAS - 7){
 c000858:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
 c00085c:	e3530008 	cmp	r3, #8
 c000860:	daffffca 	ble	c000790 <sudoku_candidatos_init_c+0x104>
 					sudoku_candidatos_propagar_thumb(cuadricula, row, col, valor_actual);
 				}
 			}
 			col++;
 		}
 		row++;
 c000864:	e51b3010 	ldr	r3, [fp, #-16]
 c000868:	e2833001 	add	r3, r3, #1
 c00086c:	e50b3010 	str	r3, [fp, #-16]
 	 * Si la celda tiene valor => sudoku_candidatos_propagar_c
 	 * Si no tiene valor => actualizar contador de celdas vacías
 	 */
 	int celdas_vacias = 0;
 	row = 0;
 	while(row < NUM_FILAS){
 c000870:	e51b3010 	ldr	r3, [fp, #-16]
 c000874:	e3530008 	cmp	r3, #8
 c000878:	daffffc1 	ble	c000784 <sudoku_candidatos_init_c+0xf8>
 			col++;
 		}
 		row++;
 	}

    return celdas_vacias;
 c00087c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
 c000880:	e1a00003 	mov	r0, r3
 c000884:	e24bd00c 	sub	sp, fp, #12
 c000888:	e89d6800 	ldm	sp, {fp, sp, lr}
 c00088c:	e12fff1e 	bx	lr

0c000890 <cuadricula_candidatos_verificar>:

static void
cuadricula_candidatos_verificar(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS],int row, int col, int *errors){
 c000890:	e1a0c00d 	mov	ip, sp
 c000894:	e92dd800 	push	{fp, ip, lr, pc}
 c000898:	e24cb004 	sub	fp, ip, #4
 c00089c:	e24dd038 	sub	sp, sp, #56	; 0x38
 c0008a0:	e50b0038 	str	r0, [fp, #-56]	; 0xffffffc8
 c0008a4:	e50b103c 	str	r1, [fp, #-60]	; 0xffffffc4
 c0008a8:	e50b2040 	str	r2, [fp, #-64]	; 0xffffffc0
 c0008ac:	e50b3044 	str	r3, [fp, #-68]	; 0xffffffbc

	uint8_t valor = celda_leer_valor(cuadricula[row][col]);
 c0008b0:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c0008b4:	e1a03283 	lsl	r3, r3, #5
 c0008b8:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c0008bc:	e0822003 	add	r2, r2, r3
 c0008c0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c0008c4:	e1a03083 	lsl	r3, r3, #1
 c0008c8:	e0823003 	add	r3, r2, r3
 c0008cc:	e1d330b0 	ldrh	r3, [r3]
 c0008d0:	e1a00003 	mov	r0, r3
 c0008d4:	ebfffe8d 	bl	c000310 <celda_leer_valor>
 c0008d8:	e1a03000 	mov	r3, r0
 c0008dc:	e54b3019 	strb	r3, [fp, #-25]	; 0xffffffe7

	/* Si el valor es distinto de 0, revisa que se haya propagado correctamente (el candidato correspondiente debe estar desactivado) */
	if(valor != 0x0000){
 c0008e0:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c0008e4:	e3530000 	cmp	r3, #0
 c0008e8:	0a0000a2 	beq	c000b78 <cuadricula_candidatos_verificar+0x2e8>
		int displace = 3 + (int)valor;
 c0008ec:	e55b3019 	ldrb	r3, [fp, #-25]	; 0xffffffe7
 c0008f0:	e2833003 	add	r3, r3, #3
 c0008f4:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

		/* Verificar el valor en todas las columnas (Horizontal) */
		int j = 0;
 c0008f8:	e3a03000 	mov	r3, #0
 c0008fc:	e50b3010 	str	r3, [fp, #-16]
		while(j < NUM_COLUMNAS - 7){
 c000900:	ea000024 	b	c000998 <cuadricula_candidatos_verificar+0x108>
			uint8_t is_bit_set = cuadricula[row][j] & (1 << displace);
 c000904:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c000908:	e1a03283 	lsl	r3, r3, #5
 c00090c:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000910:	e0822003 	add	r2, r2, r3
 c000914:	e51b3010 	ldr	r3, [fp, #-16]
 c000918:	e1a03083 	lsl	r3, r3, #1
 c00091c:	e0823003 	add	r3, r2, r3
 c000920:	e1d330b0 	ldrh	r3, [r3]
 c000924:	e20320ff 	and	r2, r3, #255	; 0xff
 c000928:	e3a01001 	mov	r1, #1
 c00092c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c000930:	e1a03311 	lsl	r3, r1, r3
 c000934:	e20330ff 	and	r3, r3, #255	; 0xff
 c000938:	e0023003 	and	r3, r2, r3
 c00093c:	e20330ff 	and	r3, r3, #255	; 0xff
 c000940:	e54b3021 	strb	r3, [fp, #-33]	; 0xffffffdf
			if(is_bit_set){
 c000944:	e55b3021 	ldrb	r3, [fp, #-33]	; 0xffffffdf
 c000948:	e3530000 	cmp	r3, #0
 c00094c:	0a00000e 	beq	c00098c <cuadricula_candidatos_verificar+0xfc>
				activar_error(cuadricula[row][j]);
 c000950:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c000954:	e1a03283 	lsl	r3, r3, #5
 c000958:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c00095c:	e0822003 	add	r2, r2, r3
 c000960:	e51b3010 	ldr	r3, [fp, #-16]
 c000964:	e1a03083 	lsl	r3, r3, #1
 c000968:	e0823003 	add	r3, r2, r3
 c00096c:	e1d330b0 	ldrh	r3, [r3]
 c000970:	e1a00003 	mov	r0, r3
 c000974:	ebfffe73 	bl	c000348 <activar_error>
				(*errors)++;
 c000978:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c00097c:	e5933000 	ldr	r3, [r3]
 c000980:	e2832001 	add	r2, r3, #1
 c000984:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000988:	e5832000 	str	r2, [r3]
			}
			j++;
 c00098c:	e51b3010 	ldr	r3, [fp, #-16]
 c000990:	e2833001 	add	r3, r3, #1
 c000994:	e50b3010 	str	r3, [fp, #-16]
	if(valor != 0x0000){
		int displace = 3 + (int)valor;

		/* Verificar el valor en todas las columnas (Horizontal) */
		int j = 0;
		while(j < NUM_COLUMNAS - 7){
 c000998:	e51b3010 	ldr	r3, [fp, #-16]
 c00099c:	e3530008 	cmp	r3, #8
 c0009a0:	daffffd7 	ble	c000904 <cuadricula_candidatos_verificar+0x74>
			}
			j++;
		}

		/* Verificar el valor en todas las filas (Vertical) */
		int i = 0;
 c0009a4:	e3a03000 	mov	r3, #0
 c0009a8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(i < NUM_FILAS){
 c0009ac:	ea000024 	b	c000a44 <cuadricula_candidatos_verificar+0x1b4>
			uint8_t is_bit_set = cuadricula[i][col] & (1 << displace);
 c0009b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c0009b4:	e1a03283 	lsl	r3, r3, #5
 c0009b8:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c0009bc:	e0822003 	add	r2, r2, r3
 c0009c0:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c0009c4:	e1a03083 	lsl	r3, r3, #1
 c0009c8:	e0823003 	add	r3, r2, r3
 c0009cc:	e1d330b0 	ldrh	r3, [r3]
 c0009d0:	e20320ff 	and	r2, r3, #255	; 0xff
 c0009d4:	e3a01001 	mov	r1, #1
 c0009d8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c0009dc:	e1a03311 	lsl	r3, r1, r3
 c0009e0:	e20330ff 	and	r3, r3, #255	; 0xff
 c0009e4:	e0023003 	and	r3, r2, r3
 c0009e8:	e20330ff 	and	r3, r3, #255	; 0xff
 c0009ec:	e54b3022 	strb	r3, [fp, #-34]	; 0xffffffde
			if(is_bit_set){
 c0009f0:	e55b3022 	ldrb	r3, [fp, #-34]	; 0xffffffde
 c0009f4:	e3530000 	cmp	r3, #0
 c0009f8:	0a00000e 	beq	c000a38 <cuadricula_candidatos_verificar+0x1a8>
				activar_error(cuadricula[i][col]);
 c0009fc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000a00:	e1a03283 	lsl	r3, r3, #5
 c000a04:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000a08:	e0822003 	add	r2, r2, r3
 c000a0c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c000a10:	e1a03083 	lsl	r3, r3, #1
 c000a14:	e0823003 	add	r3, r2, r3
 c000a18:	e1d330b0 	ldrh	r3, [r3]
 c000a1c:	e1a00003 	mov	r0, r3
 c000a20:	ebfffe48 	bl	c000348 <activar_error>
				(*errors)++;
 c000a24:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000a28:	e5933000 	ldr	r3, [r3]
 c000a2c:	e2832001 	add	r2, r3, #1
 c000a30:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000a34:	e5832000 	str	r2, [r3]
			}
			i++;
 c000a38:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000a3c:	e2833001 	add	r3, r3, #1
 c000a40:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
			j++;
		}

		/* Verificar el valor en todas las filas (Vertical) */
		int i = 0;
		while(i < NUM_FILAS){
 c000a44:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000a48:	e3530008 	cmp	r3, #8
 c000a4c:	daffffd7 	ble	c0009b0 <cuadricula_candidatos_verificar+0x120>
			}
			i++;
		}

		/* Calcular la posicion inicial para seccion correspondiente a la ubicacion actual */
		int row_start = (row / 3) * 3;
 c000a50:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
 c000a54:	e59f2128 	ldr	r2, [pc, #296]	; c000b84 <cuadricula_candidatos_verificar+0x2f4>
 c000a58:	e0c21293 	smull	r1, r2, r3, r2
 c000a5c:	e1a03fc3 	asr	r3, r3, #31
 c000a60:	e0632002 	rsb	r2, r3, r2
 c000a64:	e1a03002 	mov	r3, r2
 c000a68:	e1a03083 	lsl	r3, r3, #1
 c000a6c:	e0833002 	add	r3, r3, r2
 c000a70:	e50b3028 	str	r3, [fp, #-40]	; 0xffffffd8
		int col_start = (col / 3) * 3;
 c000a74:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
 c000a78:	e59f2104 	ldr	r2, [pc, #260]	; c000b84 <cuadricula_candidatos_verificar+0x2f4>
 c000a7c:	e0c21293 	smull	r1, r2, r3, r2
 c000a80:	e1a03fc3 	asr	r3, r3, #31
 c000a84:	e0632002 	rsb	r2, r3, r2
 c000a88:	e1a03002 	mov	r3, r2
 c000a8c:	e1a03083 	lsl	r3, r3, #1
 c000a90:	e0833002 	add	r3, r3, r2
 c000a94:	e50b302c 	str	r3, [fp, #-44]	; 0xffffffd4

		/* Verificar valor en la seccion (cuadro 3x3) */
		i = row_start;
 c000a98:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c000a9c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(i < (row_start + 3)){
 c000aa0:	ea00002f 	b	c000b64 <cuadricula_candidatos_verificar+0x2d4>
			int j = col_start;
 c000aa4:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c000aa8:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
			while(j < (col_start + 3)){
 c000aac:	ea000024 	b	c000b44 <cuadricula_candidatos_verificar+0x2b4>
				uint8_t is_bit_set = cuadricula[i][j] & (1 << displace);
 c000ab0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000ab4:	e1a03283 	lsl	r3, r3, #5
 c000ab8:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000abc:	e0822003 	add	r2, r2, r3
 c000ac0:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000ac4:	e1a03083 	lsl	r3, r3, #1
 c000ac8:	e0823003 	add	r3, r2, r3
 c000acc:	e1d330b0 	ldrh	r3, [r3]
 c000ad0:	e20320ff 	and	r2, r3, #255	; 0xff
 c000ad4:	e3a01001 	mov	r1, #1
 c000ad8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
 c000adc:	e1a03311 	lsl	r3, r1, r3
 c000ae0:	e20330ff 	and	r3, r3, #255	; 0xff
 c000ae4:	e0023003 	and	r3, r2, r3
 c000ae8:	e20330ff 	and	r3, r3, #255	; 0xff
 c000aec:	e54b302d 	strb	r3, [fp, #-45]	; 0xffffffd3
				if(is_bit_set){
 c000af0:	e55b302d 	ldrb	r3, [fp, #-45]	; 0xffffffd3
 c000af4:	e3530000 	cmp	r3, #0
 c000af8:	0a00000e 	beq	c000b38 <cuadricula_candidatos_verificar+0x2a8>
					activar_error(cuadricula[i][j]);
 c000afc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000b00:	e1a03283 	lsl	r3, r3, #5
 c000b04:	e51b2038 	ldr	r2, [fp, #-56]	; 0xffffffc8
 c000b08:	e0822003 	add	r2, r2, r3
 c000b0c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000b10:	e1a03083 	lsl	r3, r3, #1
 c000b14:	e0823003 	add	r3, r2, r3
 c000b18:	e1d330b0 	ldrh	r3, [r3]
 c000b1c:	e1a00003 	mov	r0, r3
 c000b20:	ebfffe08 	bl	c000348 <activar_error>
					(*errors)++;
 c000b24:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000b28:	e5933000 	ldr	r3, [r3]
 c000b2c:	e2832001 	add	r2, r3, #1
 c000b30:	e51b3044 	ldr	r3, [fp, #-68]	; 0xffffffbc
 c000b34:	e5832000 	str	r2, [r3]
				}
				j++;
 c000b38:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000b3c:	e2833001 	add	r3, r3, #1
 c000b40:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

		/* Verificar valor en la seccion (cuadro 3x3) */
		i = row_start;
		while(i < (row_start + 3)){
			int j = col_start;
			while(j < (col_start + 3)){
 c000b44:	e51b302c 	ldr	r3, [fp, #-44]	; 0xffffffd4
 c000b48:	e2832003 	add	r2, r3, #3
 c000b4c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
 c000b50:	e1520003 	cmp	r2, r3
 c000b54:	caffffd5 	bgt	c000ab0 <cuadricula_candidatos_verificar+0x220>
					activar_error(cuadricula[i][j]);
					(*errors)++;
				}
				j++;
			}
			i++;
 c000b58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000b5c:	e2833001 	add	r3, r3, #1
 c000b60:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		int row_start = (row / 3) * 3;
		int col_start = (col / 3) * 3;

		/* Verificar valor en la seccion (cuadro 3x3) */
		i = row_start;
		while(i < (row_start + 3)){
 c000b64:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
 c000b68:	e2832003 	add	r2, r3, #3
 c000b6c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000b70:	e1520003 	cmp	r2, r3
 c000b74:	caffffca 	bgt	c000aa4 <cuadricula_candidatos_verificar+0x214>
				j++;
			}
			i++;
		}
	}
}
 c000b78:	e24bd00c 	sub	sp, fp, #12
 c000b7c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000b80:	e12fff1e 	bx	lr
 c000b84:	55555556 	.word	0x55555556

0c000b88 <verificar_lista_calculada>:

/* Recorre la cuadricula y para cada celda llama a cuadricula_candidatos_verificar */
static int
verificar_lista_calculada(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS]){
 c000b88:	e1a0c00d 	mov	ip, sp
 c000b8c:	e92dd800 	push	{fp, ip, lr, pc}
 c000b90:	e24cb004 	sub	fp, ip, #4
 c000b94:	e24dd018 	sub	sp, sp, #24
 c000b98:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
	int errors = 0;
 c000b9c:	e3a03000 	mov	r3, #0
 c000ba0:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
	int row = 0;
 c000ba4:	e3a03000 	mov	r3, #0
 c000ba8:	e50b3010 	str	r3, [fp, #-16]
	while(row < NUM_FILAS){
 c000bac:	ea000010 	b	c000bf4 <verificar_lista_calculada+0x6c>
		int col = 0;
 c000bb0:	e3a03000 	mov	r3, #0
 c000bb4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
		while(col < NUM_COLUMNAS - 7){
 c000bb8:	ea000007 	b	c000bdc <verificar_lista_calculada+0x54>
			cuadricula_candidatos_verificar(cuadricula, row, col, &errors);
 c000bbc:	e24b3018 	sub	r3, fp, #24
 c000bc0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
 c000bc4:	e51b1010 	ldr	r1, [fp, #-16]
 c000bc8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
 c000bcc:	ebffff2f 	bl	c000890 <cuadricula_candidatos_verificar>
			col++;
 c000bd0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000bd4:	e2833001 	add	r3, r3, #1
 c000bd8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
verificar_lista_calculada(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS]){
	int errors = 0;
	int row = 0;
	while(row < NUM_FILAS){
		int col = 0;
		while(col < NUM_COLUMNAS - 7){
 c000bdc:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
 c000be0:	e3530008 	cmp	r3, #8
 c000be4:	dafffff4 	ble	c000bbc <verificar_lista_calculada+0x34>
			cuadricula_candidatos_verificar(cuadricula, row, col, &errors);
			col++;
		}
		row++;
 c000be8:	e51b3010 	ldr	r3, [fp, #-16]
 c000bec:	e2833001 	add	r3, r3, #1
 c000bf0:	e50b3010 	str	r3, [fp, #-16]
/* Recorre la cuadricula y para cada celda llama a cuadricula_candidatos_verificar */
static int
verificar_lista_calculada(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS]){
	int errors = 0;
	int row = 0;
	while(row < NUM_FILAS){
 c000bf4:	e51b3010 	ldr	r3, [fp, #-16]
 c000bf8:	e3530008 	cmp	r3, #8
 c000bfc:	daffffeb 	ble	c000bb0 <verificar_lista_calculada+0x28>
			cuadricula_candidatos_verificar(cuadricula, row, col, &errors);
			col++;
		}
		row++;
	}
	return errors;
 c000c00:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
 c000c04:	e1a00003 	mov	r0, r3
 c000c08:	e24bd00c 	sub	sp, fp, #12
 c000c0c:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000c10:	e12fff1e 	bx	lr

0c000c14 <sudoku9x9>:
/* *******************************************cuadricula[NUM_FILAS][NUM_COLUMNAS]**********************************
 * programa principal del juego que recibe el tablero,
 * y la senyal de ready que indica que se han actualizado fila y columna */
void
sudoku9x9(CELDA cuadricula[NUM_FILAS][NUM_COLUMNAS], char *ready)
{
 c000c14:	e1a0c00d 	mov	ip, sp
 c000c18:	e92dd800 	push	{fp, ip, lr, pc}
 c000c1c:	e24cb004 	sub	fp, ip, #4
 c000c20:	e24dd010 	sub	sp, sp, #16
 c000c24:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
 c000c28:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    int celdas_vacias;

    // Dos configuraciones para *init*

    celdas_vacias = sudoku_candidatos_init_c(cuadricula, 0); // Version C + C
 c000c2c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c30:	e3a01000 	mov	r1, #0
 c000c34:	ebfffe94 	bl	c00068c <sudoku_candidatos_init_c>
 c000c38:	e50b0010 	str	r0, [fp, #-16]
    verificar_lista_calculada(cuadricula);
 c000c3c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c40:	ebffffd0 	bl	c000b88 <verificar_lista_calculada>

    celdas_vacias = sudoku_candidatos_init_c(cuadricula, 1); // Version C + ARM
 c000c44:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c48:	e3a01001 	mov	r1, #1
 c000c4c:	ebfffe8e 	bl	c00068c <sudoku_candidatos_init_c>
 c000c50:	e50b0010 	str	r0, [fp, #-16]
    verificar_lista_calculada(cuadricula);
 c000c54:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c58:	ebffffca 	bl	c000b88 <verificar_lista_calculada>

    //celdas_vacias = sudoku_candidatos_init_c(cuadricula, 2); // Version C + Thumb
    //verificar_lista_calculada(cuadricula);

    celdas_vacias = sudoku_candidatos_init_arm(cuadricula, 0); // Version ARM + C
 c000c5c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c60:	e3a01000 	mov	r1, #0
 c000c64:	ebfffd18 	bl	c0000cc <sudoku_candidatos_init_arm>
 c000c68:	e50b0010 	str	r0, [fp, #-16]
    verificar_lista_calculada(cuadricula);
 c000c6c:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c70:	ebffffc4 	bl	c000b88 <verificar_lista_calculada>

    celdas_vacias = sudoku_candidatos_init_arm(cuadricula, 1); // Version ARM + ARM
 c000c74:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c78:	e3a01001 	mov	r1, #1
 c000c7c:	ebfffd12 	bl	c0000cc <sudoku_candidatos_init_arm>
 c000c80:	e50b0010 	str	r0, [fp, #-16]
    verificar_lista_calculada(cuadricula);
 c000c84:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
 c000c88:	ebffffbe 	bl	c000b88 <verificar_lista_calculada>

    //celdas_vacias = sudoku_candidatos_init_arm(cuadricula, 2); // Version ARM + Thumb
    //verificar_lista_calculada(cuadricula);
}
 c000c8c:	e24bd00c 	sub	sp, fp, #12
 c000c90:	e89d6800 	ldm	sp, {fp, sp, lr}
 c000c94:	e12fff1e 	bx	lr
